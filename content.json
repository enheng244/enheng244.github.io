{"meta":{"title":"BinSpace","subtitle":"subtitle待填充","description":"早日发财！","author":"Bin","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-08-05T16:42:14.000Z","updated":"2021-08-05T16:46:17.616Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-05T16:37:42.000Z","updated":"2021-08-05T16:39:56.400Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java多线程","slug":"java多线程","date":"2021-08-13T18:36:13.000Z","updated":"2021-08-15T20:34:21.374Z","comments":true,"path":"2021/08/14/java多线程/","link":"","permalink":"http://example.com/2021/08/14/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"线程的创建和使用 线程的声明周期 线程的同步 线程的通信 sleep()和wait()的异同 Callable接口 线程池","text":"线程的创建和使用 线程的声明周期 线程的同步 线程的通信 sleep()和wait()的异同 Callable接口 线程池 程序、进程、线程 程序：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有自身的产生、存在和消亡的过程（生命周期）。进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。 线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。一个进程同时并行执行多个线程，就是支持多线程的。线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小。一个进程的多个线程共享相同的内存单元/内存地址空间（它们从同一堆中分配对象，可以访问相同的变量和对象）。这就使得线程间通信更简便高效。但多个线程操作共享的系统资源就可能会带来安全的隐患。 栈每个线程独有 方法区和堆每个进程共享 单核多核CPU 单核CPU：假的多线程。在同一时间只能跑一个线程 多核CPU：几个单核组合起来 一个java.exe 至少有三个线程：main()主线程 gc()垃圾回收线程，异常处理线程 并行与并发 并行：多个CPU同时执行多个任务，比如多个人同时做不同的事 并发：一个CPU同时执行多个任务之间切换（显得同时执行） 多线程程序的优点 提高应用程序的响应。对图形化界面更有意义，可增强用户体验 提高计算机系统CPU的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 何时需要多线程 程序需要同时执行两个或多个任务 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。 需要一些后台运行的程序时 线程的创建（2种）和使用方式一：继承于Thread类 创建一个继承于Thread类的子类 重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start(): 启动当前线程 调用当前线程的run() 1234567891011121314151617181920public MyThread extends Thread&#123; @Override public void run()&#123; for( int i = 0; i &lt; 100; i++)&#123; System.out.println(i); &#125; &#125;&#125;public class ThreadTest&#123; public static void main(String[] args)&#123; MyThread t1 = new MyThread(); t1.start();//如果写t1.run()则只是调用了run方法而不是开启新的线程 //也可以这样创建Thread类的匿名子类 //new Thread()&#123; // //代码 //&#125;.start(); &#125;&#125; 注意： 不能通过直接调用run()的方式来启动线程 不可以让已经start()的线程去重新启动，如果想再调用则要重新创建一个线程的对象 Thread类的有关方法 void start(): 启动线程，并执行对象的run()方法 run(): 线程在被调度时执行的操作 String getName(): 返回该线程的名称 void setName(String name): 设置该线程的名称 12345678910public class Demo&#123; public static void main(String[] args)&#123; MyThread t1 = new MyThread(); t1.setName(&#x27;t1&#x27;);//要在start之前设置名字 h1.start(); //给主线程命名 THread.currentThread().setName(&#x27;主线程&#x27;); System.out.println(Thread.currentThread().getName()); &#125;&#125; static Thread currentThread(): 返回执行当前代码的线程。在Thread子类中就是This，通常用于主线程和Runnable实现类 static void yield(): 线程让步 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 若队列中没有同优先级的线程，忽略此方法 join(): 当某个程序执行流中调用其它线程的join()方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完为止 低优先级的线程也可以获得执行 static void sleep(long millis): (指定时间：毫秒) 令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队 抛出InterruptedException异常 stop(): 强制线程生命期结束，不推荐使用 boolean isAlive(): 返回boolean，判断线程是否还活着 方式二 实现Runnable接口 创建一个实现了Runnable接口的类 实现类去实现Runnable中的抽象方法:run() 创建实现类的对象 将此对象作为参数传递到THread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 12345678910111213141516public class MyThread implements Runnable&#123; @Override public void run()&#123; System.out.println(&quot;111&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread); t1.start(); Thread t2 = new Thread(myThread); t2 .start(); &#125;&#125; 两次方式的对比在开发中，优先选择Runnable接口的方式 原因：1. 实现的方式没有类的单继承性的局限性 ​ 2. 实现的方式更适合来处理多个线程共享数据的情况（因为本质上只创建了一个对象） 联系：继承的Thread类其实implements了Runnable接口 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中 线程的调度 调度策略 时间片：各个线程间来回切换 抢占式：高优先级的线程抢占cpu Java的调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的优先级 MAX_PRIORITY: 10 MIN_PRIORITY: 1 NORM_PRIORITY: 5 （默认） 涉及的方法 getPriority(): 返回线程优先值 setPriority(int newPriority): 改变线程的优先级 12345678910public class Demo&#123; public static void main(String[] args)&#123; MyThread t1 = new MyThread(); Thread.currentThread().setPriority(Thread.MIN_PRIORITY);//该主线程的优先级 h1.start(); //给主线程命名 THread.currentThread().setName(&#x27;主线程&#x27;); System.out.println(Thread.currentThread().getName()); &#125;&#125; 说明 线程创建时继承父线程的优先级 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用 线程的生命周期 JDK中用Thread.State类定义了线程的几种状态，在一个完整的生命周期中通常要经历如下的五种状态： 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被认为挂起或执行输入输出操作时，让出CPU并临时终止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地终止或出现异常导致结束 线程的同步（2+1方式）在java中，通过同步机制来解决线程的安全问题 方式一：同步代码块12345678synchronized(同步监视器)&#123; //需要被同步的代码（操作共享数据的代码） //共享数据：多个线程共同操作的变量&#125;//同步监视器，俗称 锁。任何一个类的对象，都可以充当锁。 要求：多个线程必须要公用同一把锁//好处：同步的方式，解决了线程的安全问题//坏处：操作同步代码时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低 处理继承Thread类线程安全问题12345678910111213141516171819202122232425262728293031323334353637383940class Window2 extends Thread&#123; //共享数据 private static int ticket = 100; @Override public void run()&#123; //添加同步代码块 // Class clazz =Window2.class,其中Window2.class只会加载一次 while(true)&#123; synchronized(Window2.class)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName()+&quot;:卖票,票号为:&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class Window2Test &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 补充：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类当同步监视器 处理实现Runnable接口123456789101112131415161718192021222324252627282930313233343536class Window1 implements Runnable&#123; //总票数 private int ticket = 100; @Override public void run() &#123; while(true)&#123; //设置同步代码块 // 此时的this：唯一的Window1的对象 synchronized(this)&#123; if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:卖票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w1 = new Window1(); Thread t1 = new Thread(w1); Thread t2 = new Thread(w1); Thread t3 = new Thread(w1); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this来充当同步监视器 方式二：同步方法如果操作共享数据的代码完整的声明在一个方法中，我们不妨碍将此方法声明同步的 处理继承Thread类线程安全问题123456789101112131415161718192021222324252627282930313233343536class Window3 extends Thread&#123; private static int ticket = 100; @Override public void run()&#123; while(true)&#123; show(); &#125; &#125; private static synchronized void show()&#123; //同步监视器：Window3.class //private synchronized void show()&#123;同步监视器：t1 t2 t3，这种方法是错误的 if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;：卖票，票号为：&quot;+ticket); ticket--; &#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w1 = new Window3(); Window3 w2 = new Window3(); Window3 w3 = new Window3(); w1.setName(&quot;窗口一&quot;); w2.setName(&quot;窗口二&quot;); w3.setName(&quot;窗口三&quot;); w1.start(); w2.start(); w3.start(); &#125;&#125; 处理实现Runnable接口1234567891011121314151617181920212223242526272829303132class Window4 implements Runnable&#123; private int ticket = 100; @Override public void run() &#123; while (true)&#123; show(); &#125; &#125; private synchronized void show()&#123; //同步监视器:this if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:卖票，票号为：&quot;+ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 w = new Window4(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 两种方法的总结 同步方法仍然涉及到同步监视器只是不需要我们显示的声明。 非静态的同步方法，同步监视器是：this 静态的同步方法，同步监视器是: 当前类本身 死锁 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 解决方法 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 方式三：Lock锁 ——JDK5.0新增 从JDK5.0开始，java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentranLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentranLock，可以显式加锁、释放锁 如果用继承Thread类，记得lock对象加static 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Window5 implements Runnable&#123; // 1.实例化ReentrantLock ReentrantLock lock = new ReentrantLock(); private int ticket = 100; @Override public void run() &#123; while(true)&#123; try &#123; // 2. 调用锁定方法lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;：售票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; finally &#123; // 3.调用解锁方法:unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window5 w = new Window5(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; Lock和synchronized的异同： Lock是显式锁（手动开启lock()和手动关闭锁unlock()），synchronized是隐式锁，出了作用域自动释放锁 Lock只有代码块锁，synchronized有代码锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 使用的优先顺序Lock –&gt; 同步代码块(已经进入方法体,分配了相对应资源) –&gt; 同步方法（在方法体之外） 线程的通信 涉及到的三个方法 wait(): 一旦执行此方法，当前线程就会进入阻塞状态，并释放同步监视器 notify(): 一旦执行方法，就会唤醒被 wait 的第一个线程，如果有多个线程被 wait，就唤醒优先级最高的那个 notifyAll(): 一旦执行此方法，就会唤醒所有被 wait()的线程 注意点： wait()，notify().notifyAll()：三个方法必须用在同步代码块或同步方法中。（lock也不可以用这三个） wait()，notify()，notifyAll(): 三个方法的调用者必须是同步代码块同步方法的同步监视器。否则会出现IllegalMonitorStateException异常 wait()，notify()，notifyAll()：三个方法时定义在java.lang.Object类中，不在Thread里。 释放锁： 会释放锁的操作： 当前线程的同步方法、同步代码执行结束。 当前线程在同步代码块、同步方法中遇到 break、return 终止该代码块、该方法的继承执行。 当前线程在同步代码块、同步方法中出现未处理的 Error 或 Exception，导致异常结束 当前线程在同步代码块、同步方法中执行了线程对象的 wait()方法，当前线程暂停，并释放锁 不会释放锁的操作： 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield(); 方法只是暂停当前线程的执行 线程执行同步代码块时，其他线程调用了线程的 supend()方法将线程挂起，该线程不会释放锁（同步监视器） 例子：使用两个线程打印 1-100。线程 1, 线程 2 交替打印 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Number implements Runnable&#123; private int number = 1; Object obj = new Object(); @Override public void run() &#123; while(true)&#123; synchronized(obj)&#123; //唤醒线程 obj.notify(); if(number &lt;= 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:&quot; +number); number++; try &#123; // 使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; sleep()和wait()的异同 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态 不同点： 两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait() 调用的要求不同：sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中 如果两个方法都使用在同步代码块或同步方法中,sleep()不会释放锁，wait()会 JDK5.0 新增线程创建方式（2种）新增方式一：实现Callable接口 与Runnable相比，Callable功能更强大些 call()相比run()方法，可以有返回值 方法可以抛出异常，被外面的操作捕获，获取异常信息 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 Future接口 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等 FutureTask是Future接口的唯一的实现类 FutureTask同时实现了Runnable，Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值 步骤 创建一个实现Callable的实现类 实现call方法，将此线程需要执行的操作声明在call()中 创建Callable接口实现类的对象 将此Callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask的对象 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread的对象，并调用start() 获取Callable中call方法的返回值 1234567891011121314151617181920212223242526class NumThread implements Callable&#123; int sum = 0; @Override public Object call() throws Exception&#123; System.out.println(&quot;aaa&quot;); &#125; return sum;//自动装箱 //如果没必要有返回值则返回null&#125;public class ThreadNew&#123; public static void main(Sting[] args)&#123; NumThread numThread = new NumThread(); FutureTask futureTask = new FutureTask(numThread); new Thread(futureTask).start(); try&#123; //get()返回值即为FutureTask构造器参数Callable实现类重新的call()的返回值 Object sum = new futureTask.get(); System.out.println(sum); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125;catch(ExcutionException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 新增方式二：使用线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度（减少了创建线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 …. 线程池相关API JDK5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService: 真正的线程池接口。常见子类（实现类）ThreadPoolExecutor void execute(Runnable command): 执行任务/命令，没有返回值，一般用来执行Runnable Future submit(Callable task): 执行任务，有返回值，一般用来执行Callable void shutdown(): 关闭连接池 Executors: 工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool(): 创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n): 创建一个可重用固定线程数的线程池（常用） Executors.newSingleThreadExecutor(): 创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n): 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行 123456789101112131415161718public class ThreadPool&#123; public static void main(String[] args)&#123; //1.提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); //设置线程池的属性 ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; service1.setCorePoolSize(15); //service1.setKeepAliveTime(); //2.执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumThread1()); service.execute(new NumThread2()); //service.submit(Callable callable); //3.关闭连接池 service.shutdown(); &#125;&#125;","categories":[],"tags":[]},{"title":"java集合框架","slug":"java集合框架","date":"2021-08-12T15:36:20.000Z","updated":"2021-08-15T20:35:32.933Z","comments":true,"path":"2021/08/12/java集合框架/","link":"","permalink":"http://example.com/2021/08/12/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"集合","text":"集合 集合概念：对象的容器，定义了对对象常用的操作，类似数组功能 和数组的区别 数组长度固定，集合长度不固定 数组可以存储基本类型和引用类型，集合只能存储引用类型 位置：java.util.* Collection体系集合","categories":[],"tags":[]},{"title":"常用类","slug":"java常用类","date":"2021-08-09T08:02:11.000Z","updated":"2021-08-12T15:35:51.667Z","comments":true,"path":"2021/08/09/java常用类/","link":"","permalink":"http://example.com/2021/08/09/java%E5%B8%B8%E7%94%A8%E7%B1%BB/","excerpt":"Object类 包装类 String类 BigDecimal Date Calendar SimpleDateFormat System类","text":"Object类 包装类 String类 BigDecimal Date Calendar SimpleDateFormat System类 Object类 java.lang.Object 超类，基类，所有类的直接或间接父类，位于继承树的最顶层 任何类如果没有extends，都默认直接继承Object类 Object类中定义的方法，是所有对象都具备的方法 Object类型可以存储任何对象 作为参数，可接受任何对象 作为返回值，可返回任何对象 getClass()12345678910public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;aaaa&quot;); Student s2 = new Student(&quot;bbbb&quot;); //判断s1和s2是不是同一个类型 Class class1 = s1.getClass(); Class class2 = s2.getClass(); class1 == class2 //true &#125;&#125; public final Class get Class(){} //Class是一种返回值类型 返回引用中存储的实际对象类型 应用：通常用于判断两个引用中实际存储对象类型是否一致 在反射中会用到 hashcode() public int hashCode(){} 返回该对象的哈希码值 哈希值是根据对象的地址或字符串或数字使用hash算法计算出来的int类型的数值 一般情况下相同对象返回相同哈希码，也就是说可以通过这个方法来判断两个对象是不是相同 12345678910111213public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;aaaa&quot;); Student s2 = new Student(&quot;bbbb&quot;); //hashcode int hash1 = s1.hashCode(); int hash2 = s2.hashCode(); hash1 == hash2; //false Student s3 = s1; hash1 == hash3; //True &#125;&#125; toString() public String toString(){} 返回该对象的字符串表示 12345678public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;aaaa&quot;); Student s2 = new Student(&quot;bbbb&quot;); //toString方法 System.out.println(s1.toString());//输出package.TestStudent@s1的哈希值 &#125;&#125; 可以根据程序需求覆盖（重写）该方法，如：展现对象的各个属性值 123456public class Student&#123; //重写toString public String toString()&#123; return &quot;Student [name=&quot; + name + &quot;]&quot;; &#125;&#125; Integer.toString()有一个重载方法 .toString(i, radix) radix代表进制 比如Integer.toString(15, 16)是f equals() public boolean equals(Object obj){} 默认实现为（this==obj），比较两个对象的地址是否相同 123456789101112public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;aaaa&quot;); Student s2 = new Student(&quot;bbbb&quot;); //equals方法：判断两个对象是否相等 s1.equals(s2);//false Student s4 = new Student(&quot;a&quot;); Student s5 = new Student(&quot;a&quot;); s4.equals(s5);//false 比较的是地址 &#125;&#125; 可进行重写，比较两个对象的内容是否相同，步骤： 比较两个引用是否指向同一个对象 判断obj是否为null 判断两个引用指向的实际对象类型是否一致 强制类型转换 依次比较各个属性值是否相同 1234567891011121314151617181920public class Student&#123; //重写equals public boolean equals(Object obj)&#123; //1比较两个引用是否指向同一个对象 if(this == obj)&#123; return true;&#125; //2判断obj是否为null if(obj == null)&#123; return false;&#125; //3判断两个引用指向的实际对象类型是否一致 //if(this.getClass()==obj.getClass())&#123;&#125;比较笨重的方法，也可行 if(obj instanceof Student)&#123;//instanceof判断对象是否是某种类型 //4强制类型转换 Student s = (Student)obj; //5比较属性 if(this.name.equals(s.getName())&amp;&amp;this.age.equals(s.getAge()))&#123; return true; &#125; &#125; return false; &#125;&#125; finalize() 当对象被判定为垃圾对象时，由JVM此方法，用来标记垃圾对象，进入回收队列 垃圾对象：没有有效引用指向此对象时，为垃圾对象 垃圾回收：由GC销毁垃圾对象，释放存储空间 自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象 手动回收机制：使用System.gc() 通知JVM执行垃圾回收 一般不用程序员自己调用 包装类 都在java.lang中 基本数据类型所对应的引用数据类型 Object可统一所有数据，包装类的默认值是null 基本数据类型（栈） 包装类型（堆） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 类型转换与装箱、拆箱需保证类型兼容，否则抛出NumberFormatException异常 装箱：栈到堆 拆箱：堆到栈 123456789101112131415161718192021public class Demo&#123; public static void main(String[] args)&#123; //JDK1.5之前 //类型转换：装箱，基本类型转成引用类型的过程 int num1 = 18;//基本类型 //使用Integer类创建对象 Integer integer1 = new Integer(num1); Integer integer2 = Integer.valueOf(num1); //类型转换：拆箱，引用类型转成基本类型的过程 Integer integer3 = new Integer(100);//引用类型 int num2 = integer3.intValue(); //在JDK1.5之后，Java提供自动装箱和拆箱 int age = 30; //自动装箱:自动会调用Integer.valueOf Integer integer4 = age; //自动拆箱 int age2 = integer4; &#125;&#125; **parseXXX()**静态方法 12345678910111213141516171819202122public class Demo&#123; public static void main(String[] args)&#123; //基本类型和字符串之间转换 //1 基本类型转成字符串 int n1 = 100; //1.1 使用+号 String s1 = n1 + &quot;&quot;; //1.2 使用Integer中的toString() String s2 = Integer.toString(s1); //字符串转成基本类型 String str = &quot;150&quot;; //使用Integer.parseXXX() int n2 = Integer.parseInt(str); //boolean类型字符串形式转成基本类型，&quot;true&quot; ----&gt; true 非&quot;true&quot;---&gt;false String str2 = &quot;true&quot;; boolean b1 = Boolean.parseBoolean(str2);//true String str3 = &quot;sdasd&quot;; boolean b2 = Boolean.parseBoolean(str3);//false &#125;&#125; valueOf()静态方法 整数缓冲区 Java预先创建了256个常用的整数包装类型对象 (-128到127) 在实际应用中，对已创建的对象进行复用 12345678910111213141516public class Demo&#123; public static void main(String[] args)&#123; //面试题 Integer integer1 = new Integer(100); Integer integer2 = new Integer(100); System.out.println(integer1 == integer2);//true Integer integer3 = Integer.valueOf(100); Integer integer4 = Integer.valueOf(100); System.out.println(integer3 == integer4);//true Integer integer5 = Integer.valueOf(200); Integer integer6 = Integer.valueOf(200); System.out.println(integer5 == integer6);//false &#125;&#125; String类 字符串是常量，创建之后不可改变 字符串字面值存储在字符串池（在方法区）中，可以共享 1234567public class Demo&#123; public static void main(String[] args)&#123; String name = &quot;hello&quot;; //&quot;hello&quot; 常量存储在字符串池中 name = &quot;zhangsan&quot;; String name2 = &quot;zhangsan&quot;; &#125;&#125; String s = “Hello” 产生一个对象，字符串池中存储 String s = new String(“Hello”) 产生两个对象，堆、池各存储一个 但实际运行的时候堆中的内容是指向方法区的存储地址 12345678public class Demo&#123; public static void main(String[] args)&#123; String str = new String(&quot;java&quot;); String str2 = new String(&quot;java&quot;); System.out.println(str == str2);//false System.out.println(str.equals(str2));//true 这里的equals在String里重写了 &#125;&#125; 常用方法 public int length(): 返回字符串的长度（汉字和空格也是1位） public char charAt(int index): 根据下标获取字符 public boolean contains(String str): 判断当前字符串中是否包含str public char[] toCharArray(): 将字符串转换成数组 public int indexOf(String str): 查找str首次出现的下标，存在则返回该下标（第一个字符），不存在则返回-1 public int lastIndexOf(String str): 查找字符串在当前字符串中最后一次出现的下标索引 public String trim(): 去掉字符串前后的空格 public String toUpperCase(): 将小写转成大写 public boolean endWith(String str): 判断字符串是否以str结尾 public String replace(char oldChar, char newChar): 将旧字符串替换成新字符串 public String[] split(String str): 根据str做拆分 compareTo()：比较大小，比较字典表里的顺序(第一位字符相减的得数，相同就比第二位) equals() 可变字符串 StringBuffer: 可变长字符串，JDK1.0提供，运行效率慢、线程安全 StringBuilder：可变长字符串，JDK5.0提供，运行效率快、线程不安全 和String区别： 效率比String高 比String节省内存 12345678910111213141516171819public class Demo&#123; public static void main(String[] args)&#123; StringBuffer sb = new StringBuffer(); //StringBuild sb = new StringBuild();也可以，下面的方法一样 //1 append()追加 sb.append(&quot;a&quot;);//a sb.append(&quot;b&quot;);//ab sb.append(&quot;c&quot;);//abc //2 insert() 添加 sb.insert(&quot;0,z&quot;);//zabc //3 replace() 替换 sb.replace(0,2,&quot;sss&quot;);//sssbc 左闭右开 //4delete() 删除 sb.delete(0,2);//sbc 左闭右开 sb.delete(0,sb.length());//清空 //输出用toString System.out.println(sb.toString()); &#125;&#125; BigDecimal123456789public class TestBigDecimal&#123; public static void main(String[] args)&#123; double d1 = 1.0; double d2 = 0.9; System.out.println(d1-d2);//会输出0.09999999999 double result = (1.4-0.5)/0.9; System.out.println(d1-d2);//会输出0.9999999999 &#125;&#125; 因为double是近似值存储，需要精确运算则需要借助BigDecimal 位置：java.math包中 作用：精确计算浮点数 创建方式：BigDecimal bd = new BigDecimal(“1.0”); 12345678public class TestBigDecimal&#123; public static void main(String[] args)&#123; BigDecimal bd1 = new BigDecimal(&quot;1.0&quot;); BigDecimal bd2 = new BigDecimal(&quot;0.9&quot;); BigDecimal r1 = bd1.subtract(bd2);//r1=0.1 //加法是.add() 减法是.subtract() 乘法是. multiply() 除法.divide()但是除不尽的时候要写保留几位小数或者声明四舍五入，否则会报错 &#125;&#125; 时间类型Date Date表示特定的瞬间，精确到毫秒。JKD1.1后，Date类中的大部分方法都已经被Calendar类中的方法所取代（因为在设计的时候不是很完美） 时间单位 1秒=1000毫秒 1毫秒=1000微秒 1微秒=1000纳秒 Calendar Calendar提供了获取或设置各种日历字段的方法 构造方法 protected Calendar():由于修饰符是protected 所以无法直接创建该对象 其他方法 12345678910111213141516171819202122232425262728public class Demo&#123; public static void main(String[] args)&#123; //1创建Calendar对象 Calendar calendar = Calendar.getInstance(); //输出 System.out.println(calendar.getTime().toLocaleString()); System.out.println(calendar.getTimeInMillis()); //2获取时间信息 //获取年 int year = calendar.get(Calendar.YEAR);//在Calendar源码中定义了常量YEAR=1 //月 0-11 int month = calendar.get(Calendar.MONTH); //日 int day = calendar.get(Calendar.DAY_OF_MONTH); //小时 int hour = calendar.get(Calendar.HOUR_OF_DAY);//24小时 int hour = calendar.get(Calendar.HOUR);//12小时 //分钟 int minute = calendar.get(Calendar.MINUTE); //秒 int second = calendar.get(Calendar.SECOND); //修改时间 Calendar calendar2 = Calendar.getInstance(); calendar2.set(Calendar.DAY_OF_MONTH, 5); calendar2.add(Calendar.HOUR, 1);//加一小时 减一小时可以-1 &#125;&#125; SimpleDateFormat SimpleDateFormat是一个以与语言环境有关的方法来格式化和解析日期的具体类 进行格式化（日期 –&gt; 文本）、解析（文本 –&gt; 日期） 常用的时间模式字母 12345678910111213public class Demo&#123; public static void main(String[] args)&#123; //1创建SimpleDateFormat对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); //2创建Date Date date = new Date(); //格式化date String str = sdf.format(date); System.out.println(str); //解析 Date date2 = sdf.parse(&quot;2021年02月12日 12-23-45&quot;) &#125;&#125; Syetem类 System系统类，主要用于获取系统的属性数据和其他操作，构造方法私有，方法都是静态的，因此使用的时候不用创建对象 123456789101112131415161718public class Demo&#123; public static void main(String[] args)&#123; //arraycopy 数组的复制 //是native方法，底层的c++，运行速度快 //Arrays.copyOf(original, newLength)的源码里是调用的System.arrayCopy /* 参数 src 源数组 srcPos 从哪个位置开始复制 dest 目标数组 destPos 目标数组的开始放的位置 length 复制的长度 */ int[] arr = &#123;2, 4, 3, 3, 21&#125;; int[] dest = new int[8]; System.arraycopy(arr,0,dest,0,arr.length); &#125;&#125;","categories":[],"tags":[]},{"title":"异常机制","slug":"异常机制","date":"2021-08-08T17:45:25.000Z","updated":"2021-08-08T19:14:49.791Z","comments":true,"path":"2021/08/09/异常机制/","link":"","permalink":"http://example.com/2021/08/09/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/","excerpt":"简单分类 异常体系结构 Error Exception 异常处理机制 自定义异常 实际经验","text":"简单分类 异常体系结构 Error Exception 异常处理机制 自定义异常 实际经验 异常异常指程序运行中出现的不期而至的各种情况，如：文件找不到、网络连接失败、非法参数等。 异常发生在程序运行期间，它影响了正常的程序执行流程。 简单分类 检查性异常（测试岗的人的主要工作） 是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在的文件时，一个异常就发生了，这些异常在编译时不能被简单的忽略 运行时异常 可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略 错误（ERROR） 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如当栈溢出时，一个错误就发生了，它们在编译也检查不到 异常体系结构Java把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中已经定义了许多的异常类，这些异常类分为两大类，错误Error（无法预见）和异常Exception（可以预见） AWTEError有关于GUI ErrorError对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关 这些异常发生时，Java虚拟机（JVM）一般会选择终止线程。 Exception在Exception分支中有一个重要的子类RunTimeException（运行时异常） ArrayIndexOutOfBoundsException（数组下标越界） NullPointerException（空指针异常） ArithmeticException（算数异常） MissingResourceException（丢失资源） ClassNotFoundException（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理也可以不处理 这些异常一般有程序逻辑错误引起，应该尽可能避免 和Error的区别：Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，JVM一般会选择终止线程。Exception通常是可以被程序处理的，并且在程序中应尽可能的去处理这些异常 异常处理机制 抛出异常 捕获异常 异常处理的五个关键字：try catch finally throw throws try-catch-finally快捷键：选中代码Ctrl+Alt+t 12345678910111213141516171819public class Test&#123; public static void main(String[] args)&#123; int a = 1; int b = 0; try&#123;//try监控区域 System.out.println(a/b); &#125;catch(ArithmeticException e)&#123;//想要捕获的异常类型 //语句 可以打印错误信息，也可以System.exit()退出程序 &#125;catch(Exception e )&#123; //可以有多个catch &#125;catch(Throwable t)&#123; //把范围大的写在后面，因为一旦有catch执行就直接跳过其他的catch进入finally &#125;finally&#123; //处理善后工作，无论catch执没执行，finally一定执行 //可以不要finally //一般用来关闭资源 &#125; &#125;&#125; throw throws123456789101112public class Test&#123; public static void main(String[] args)&#123; &#125; public void test(int a, int b) throws ArithmeticException&#123;//假设在方法中，不能用throw处理异常，在方法上用throws抛出异常 if (b==0)&#123; throw new ArithmeticException();//主动抛出的异常，throw一般在方法中用 &#125; a/b &#125;&#125; 自定义异常使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。 步骤： 创建自定义异常类 在方法中通过throw抛出异常对象 如果在当前抛出异常的方法中处理异常，可以用try-catch语句并处理；否则在方法的声明处通过throws指明要抛出给方法调用者的异常，继续进行下一步操作 在出现异常方法的调用者中捕获并处理异常 1234567891011121314151617181920212223242526272829public class MyException extends Exception()&#123; //传递数字&gt;10 private int detail; public MyException(int a)&#123;//构造器 this.detail = a; &#125; //异常的打印信息 @Override public String toString()&#123; return &quot;MyException&#123;&quot; + detail + &quot;&#125;&quot;; &#125;&#125;public class Test&#123; //可能会存在异常的方法 加static是为了不用建对象 static void test(int a) throws My Exception&#123; if(a&gt;10)&#123; throw new MyException(a);//抛出 &#125; &#125; public static void main(String[] args)&#123; try&#123; test(11); &#125;catch(MyException e)&#123; System.out.println(&quot;MyException:&quot; + e); &#125; &#125;&#125;//结果会输出MyException:MyException&#123;11&#125; 实际经验 常用类（object类–hashcode() toString() clone() getClass() notify() wait() equals() Math类 Random类 File类(增删改查文件) 包装类（自动拆箱和装箱） Data类(Date SimpleDateFormat Calendar) String类(操作量较少) StringBuffer(可变长 append() 多线程数据量大 效率低安全) Stringbuilder(可变长 单线程数据量较大 效率高不安全)） io 集合","categories":[],"tags":[]},{"title":"数据结构","slug":"数据结构","date":"2021-08-07T17:26:51.000Z","updated":"2021-08-07T19:27:09.502Z","comments":true,"path":"2021/08/08/数据结构/","link":"","permalink":"http://example.com/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"初步","text":"初步 数据结构的存储方式数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储） 队列和栈既可以用数组（要处理扩容缩容的问题），也可以用链表（需要更多的内存空间存储节点指针）实现 图的两种表示方法：邻接表（比较省空间，效率不如邻接矩阵）是链表，邻接矩阵（判断连通性迅速，可以进行矩阵运算去解决问题，但是如果图比较稀疏的话会很耗空间）是二维数组。 散列表是通过散列函数把键映射到一个大数组里。对于解决散列冲突的方法，拉链法需要链表特性，操作简单但需要额外的空间存储指针。线性探查法需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。 树：用数组实现就是堆，因为堆是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单。用链表实现常见的树，在链表树的基础上又衍生出了二叉搜索树，AVL树，红黑树，区间树，B树等等 Redis数据库提供列表、字符串、集合等等几种常用数据结构，但是底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。 二者的优缺点： 数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组**如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)**。 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 数据结构的基本操作对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。 而所有操作可以分成线性（for/while）和非线性（递归）两种。 数组的遍历框架（线性迭代结构） 12345void traverse(int[] array)&#123; for(int i=0; i &lt; array.length; i++)&#123; //迭代访问array[i] &#125;&#125; 链表的遍历框架（线性和非线性都可以） 123456789101112131415//基本的单链表节点class ListNode&#123; int val; ListNode next;&#125;//线性迭代void traverse(Listnode head)&#123; for(ListNode p = head; p != null; p = p.next)&#123; &#125;&#125;//递归void traverse(Listnode head)&#123; traverse(head.next);&#125; 二叉树的遍历框架（非线性递归结构） 12345678910//基本的二叉树节点class TreeNode&#123; int val; TreeNode left, right;&#125;void traverse(TreeNode root)&#123; traverse(root.left); traverse(root.right);&#125; 扩展为N叉树的遍历框架 1234567891011//基本的N叉树节点class TreeNode&#123; int val; TreeNode[] children;&#125;void traverse(TreeNode root)&#123; for(TreeNode child; root.children)&#123; traverse(child); &#125; &#125; 二叉树的遍历1234567void traverse(TreeNode root) &#123; // 前序遍历 traverse(root.left) // 中序遍历 traverse(root.right) // 后序遍历&#125; 刷题顺序相关先单链表，再二叉树，栈和队列","categories":[],"tags":[]},{"title":"面向对象","slug":"面向对象","date":"2021-08-07T12:21:17.000Z","updated":"2021-08-08T17:44:13.879Z","comments":true,"path":"2021/08/07/面向对象/","link":"","permalink":"http://example.com/2021/08/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"创建和初始化对象 封装 重载 继承 重写 多态 Instanceof 类型转换 Static 代码块 抽象类 接口 内部类","text":"创建和初始化对象 封装 重载 继承 重写 多态 Instanceof 类型转换 Static 代码块 抽象类 接口 内部类 面向对象 面向对象的本质：以类的方式组织代码，以对象的组织（封装）数据 抽象 三大特性 封装 继承 多态 创建和初始化对象使用new关键字创建对象 使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。 类中的构造器也称为构造方法，是在创建对象时必须要调用的。并且构造器有以下两个特点 必须与类的名字相同 必须没有返回类型，也不能写void 构造器的核心作用 使用new关键字，本质是在调用构造器 用来初始化对象的值 要注意，一旦定义了有参构造器，无参构造器就必须显示定义（程序不会再自动生成） tip: 在ideaj中alt+enter 生成构造器 封装程序设计要追求 高内聚，低耦合 属性私有，get/set 1234567891011121314151617181920212223public class student&#123; private String name; private int id; private char sex; public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getId()&#123; return this.id; &#125; public void setId(int id)&#123; this.id = id; &#125; public char getSex()&#123; return this.sex; &#125; public char setSex(char sex)&#123; this.sex = sex; &#125;&#125; 在ideaj里按alt+insert加get、set方法 封装的意义 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 系统可维护增加了 重载在一个类中，有相同的类型，但是有不同的参数类型 仅仅方法的返回值类型不同不可以是重载 继承继承的本质是对一批类的抽象 Java中类只有单继承，没有单继承（extends后面只能跟一个） 继承是类和类之间的一种关系，除此之外的关系还有依赖、组合、聚合等 继承关系的两个类，一个为子类（派生类），一个为父类（基类） 子类和父类之间具有 ‘is a’ 的关系 子类无法继承父类中private的属性和方法 可以 父类 a = new 子类(); 即父类的引用可以指向子类 object类 在Java中，所有的类，都默认直接或者间接继承Object super 用super调用父类的构造方法，super必须在子类构造器的第一行 super只能出现在子类的方法或者构造器中 super和this不能同时调用构造方法（因为都要在第一行） VS this： 代表的对象不同： this：本身调用者这个对象 super：只能在继承条件才可以使用 前提 this：没有继承也可以使用 super：只能在继承条件才可以使用 构造方法 this：本类的构造 super：父类的构造 方法重写重写都是方法的重写，和属性无关 前提：需要有继承关系，子类重写父类的方法 注意点 方法名必须相同 参数列表必须相同 修饰符：范围可以扩大，但不能缩小，public &gt; protected &gt; default &gt; private 抛出的异常：范围可以被缩小，但不能扩大 ClassNotFoundException –&gt; Exception(大) 重写子类和父类必须要一致，方法体不同 为什么需要重写： 父类的功能，子类不一定需要，或者不一定满足 Alt+Insert:Override 多态 即同一方法可以根据发送对象的不同而采取多种不同的行为方式 一个对象的实际类型是确定的，但是可以指向对象的引用的类型有很多（父类，父类的父类或有关系的类） 多态注意事项： 多态是方法的多态，属性没有多态 父类和子类要有联系（有类型转换异常 ClassCastException） 存在条件：继承关系，方法需要重写，父类引用指向子类对象 Father f1 = new Son(); 不能被重写的： static 方法，属于类，它不属于实例 final 常量 private方法 12345678910111213141516171819202122232425262728293031323334353637383940//父类public class Person&#123; public void run()&#123; System.out.println(&quot;run&quot;); &#125;&#125;//子类public class Student extends Person&#123; @Override public void run()&#123; System.out.println(&quot;son&quot;); &#125; public void eat()&#123; System.out.println(&quot;eat&quot;); &#125;&#125;//测试类public class Application&#123; public static void main(String[] args)&#123; /*一个对象的实际类型是确定的，即new后面的是确定的， 比如 new Student() new Person() 但是前面可以指向的引用类型就不确定了：父类的引用指向子类 比如Person a = new Student() */ //Student能调用的方法都是自己的或者是继承父类的 Student s1 = new Student(); //Person父类可以指向子类，但是不能调用子类独有的方法 Person s2 = new Student(); Object s3 = new Student(); //能调用什么方法主要看前面的引用，和右边关系不大 s1.eat();//输出eat ((Student) s2).eat();//向下强制转换，输出eat s1.run();//输出son s2.run();//输出son &#125;&#125; InstanceofX instanceof Y 如果X和Y有父子关系，编译就通过，如果没有编译就报错 123456789101112131415161718192021222324252627282930313233//父类public class Person&#123;&#125;//子类public class Student extends Person&#123;&#125;//子类public class teacher extends Person&#123; &#125;//测试类public class Application&#123; public static void main(String[] args)&#123; Object object = new Student(); //object &gt; String //object &gt; Person &gt; Teacher //object &gt; Person &gt; Student System.out.println(object instanceof Student);//true System.out.println(object instanceof Person);//true System.out.println(object instanceof Object);//true System.out.println(object instanceof Teacher);//false System.out.println(object instanceof String);//false Person person = new Student(); System.out.println(person instanceof String);//完全没有关系的两项，编译会报错 Student student = new Student(); System.out.println(object instanceof Teacher);//编译会报错 System.out.println(object instanceof String);//编译会报错 &#125;&#125; 类型转换父类辈分比子类高 子类可以自动转换为父类，但是可能会丢失一些自己本来的方法 父类转成子类需要强制转换 可以理解成，比如父类是人，子类是学生，子类的学生可以自动说成人，但是会丢失自己的特点，但是人不一定都是学生，需要强制转换 Static和类一起最先加载，可以直接通过类调用 123456789101112131415161718public class Student&#123; private static int age;//静态属性 private double score; public void run()&#123; &#125; public static void go()&#123; //静态方法 &#125; public static void main(String[] args)&#123; new Student().score; new Student().age; new Student().run(); Student.age;//静态属性可以直接用类调用 Student.go()//静态方法可以直接用类调用 &#125;&#125; 代码块123456789101112public class Person&#123; &#123; //代码块（匿名代码块） //对象建立的时候被调用，在构造器之前调用 //可以用来初始化 &#125; static&#123; //静态代码块 //在类加载的时候执行，永久只执行一次 &#125;&#125; 抽象类123456//关键字abstract 需要子类去extendspublic abstract class Action&#123; //abstract 抽象方法，只有方法名字，没有方法的实现 public abstract void doSth(); &#125; 不能new这个抽象类，只能靠子类来，只能靠子类去实现他它 抽象类中可以写普通的方法 抽象方法必须在抽象类中 抽象类有构造器 抽象类的所有方法，继承它的子类，都必须要重写它的方法，除非子类也是抽象类 接口（interface）普通类：只有具体实现 抽象类：具体实现和规范（抽象方法）都有 接口：只有规范，自己无法写方法 （比抽象类还要抽象，约束和实现分离：面向接口编程） 1234567891011121314151617181920212223242526272829303132333435//接口 关键字interface 接口都需要实现类public interface UserService&#123; //常量 （public static final) //但是一般不会再接口类设置常量 int AGE=99; //接口中的所有定义的方法都是抽象的 (public abstract) void add(String name); void delete(String name); void update(String name); void query(String name);&#125;//实现类用implements//实现了接口的类，必须重写接口中的方法//可以实现两个接口，将两个接口的方法全部重写public class UserServiceImpl implements UserService&#123; @Override public void add(String name)&#123; &#125; @Override public void delete(String name)&#123; &#125; @Override public void update(String name)&#123; &#125; @Override public void query(String name)&#123; &#125;&#125; 接口的作用： 约束 定义一些方法，让不同的人实现 public abstract public static final 接口不能被实例化，接口中没有构造方法 implements可以实现多个接口 必须要重写接口中的方法 内部类内部类就是在一个类的内部再定义一个类，比如A类中定义了一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类 成员内部类 12345678910111213141516171819202122232425public class outer&#123; private int id=10; public void out()&#123; System.out.println(&quot;out&quot;); &#125; class Inner&#123; public void in()&#123; System.out.println(&quot;in&quot;); &#125; //获得外部类的私有属性 public void getID()&#123; System.out.println(id); &#125; &#125;&#125;public class Application&#123; public static void main(String[] args)&#123; Outer outer = new Outer(); //通过外部类来实例化内部类 Outer.Inner inner = outer.new Inner(); inner.in();//输出in inner.getId();//输出10 &#125;&#125; 静态内部类（内部类是public static class Inner{}） 局部内部类(内部类在外部类的方法里) 1234567public class Outer&#123; public void method&#123; class Inner&#123; &#125; &#125;&#125; 匿名内部类 1234567891011121314151617181920212223public class Test&#123; public static void main(String[] args)&#123; //没有名字初始化类，不用将实例保存到变量中 new Apple().eat(); new UserService()&#123;//不重写方法会报错 @Override public void hello()&#123; &#125;; &#125; &#125;&#125;public class Apple&#123; public void eat&#123; &#125;&#125;public interface UserService&#123; void hello();&#125;","categories":[],"tags":[]},{"title":"数组","slug":"数组","date":"2021-08-06T09:14:04.000Z","updated":"2021-08-06T17:33:32.414Z","comments":true,"path":"2021/08/06/数组/","link":"","permalink":"http://example.com/2021/08/06/%E6%95%B0%E7%BB%84/","excerpt":"数组的定义，声明，创建 内存分析 数组的三种初始化四个基本特点，使用 多维数组 Arrays类 冒泡排序 稀疏数组","text":"数组的定义，声明，创建 内存分析 数组的三种初始化四个基本特点，使用 多维数组 Arrays类 冒泡排序 稀疏数组 数组的定义数组是相同类型数据的有序集合 其中每一个数据称作一个数组元素，通过下标访问 数组的声明和创建123456789//声明数组int[] a;//首选int a[];//c和c++风格//创建数组int[] nums = new int[10];//赋值 没有赋值则自动取默认值int[0] = 0;//获取数组长度arrays.length; 内存分析 堆 存放new的对象和数组 可以被所有的线程共享，不会存放别的对象引用 栈 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里的具体地址） 方法区 可以被所有的线程共享 包含了所有的class和static变量 数组的三种初始化 数组的四个基本特点 长度是确定的，一旦被创建，大小不可以再改变 其元素必须是相同类型，不能混合 元素可以是基本类型也可以是引用类型 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组本身是在堆中 数组的使用 For-Each循环 123for(i=0;i&lt;arrays.length;i++)&#123; &#125; 数组作方法入参 123for(int array :arrays)&#123; //增强for循环，JDK1.5开始可以， 这样取不到下标 &#125; 数组作返回值 多维数组可以看做是数组的数组，比如二维数组 12345int[][] a = new int[3][2];int[][] a = &#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;4,5&#125;&#125;;//获取长度a.length;//3a[0].length;//2 Arrays类数组的工具类java.util.Arrays 里面的方法都是用static修饰的静态方法 冒泡排序总共有八大算法 冒泡排序有两层循环，外层冒泡轮数，里层依次比较 时间复杂度为O(n2) 代码 12345678910111213public int[] sort(int[] array)&#123; int temp = 0; for(int i=0; i &lt; array.length-1; i++)&#123; for(int j = 0; j &lt; array.length-1-i; j++)&#123; if(array[j] &gt; array[j+1])&#123; temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; return array;&#125; 稀疏数组是一种数据结构（一共三列） 当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方式是： 记录数组一共有几行几列，有多少个不同值 把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模。下图左边是原始数组，右边是稀疏数组。 第一行保存数组的行数，列数，有效值的个数 其他行保存有效值的行，列，本身的值","categories":[],"tags":[]},{"title":"java方法","slug":"java方法","date":"2021-08-05T14:16:55.000Z","updated":"2021-08-06T09:13:32.647Z","comments":true,"path":"2021/08/05/java方法/","link":"","permalink":"http://example.com/2021/08/05/java%E6%96%B9%E6%B3%95/","excerpt":"定义 调用 重载 命令行传参 可变参数 递归","text":"定义 调用 重载 命令行传参 可变参数 递归 原子性：一个方法最好只完成一个功能，方便维护 方法的定义类似于其他语言的函数 方法包含一个方法头和一个方法体 1234修饰符 返回值类型 方法名(参数类型 参数名)&#123; //方法体 return 返回值;&#125; 形式参数：在方法被调用时用于接收外界输入的数据 实际参数：调用方法时实际传给方法的数据 方法的调用调用方法：对象名.方法名（实参列表） 值传递(java)和引用传递 方法的重载在一个类中，有相同的类型，但是有不同的参数类型 仅仅方法的返回值类型不同不可以是重载 命令行传参1234567public class CommandLine&#123; public static void main(String[] args)&#123; for(int i=0; i&lt;args.length;i++)&#123; System.out.println(args[i]); &#125; &#125;&#125; 可变参数（不定项参数）JDK1.5开始，Java支持传递同类型的可变参数给一个方法 在指定参数类型后加一个省略号，三个点(…) 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明 123public void test(int... num)&#123; //相当于是传递了num[]数组进来&#125; 递归递归头：什么时候不调用自身方法，如果没有头，将陷入死循环 递归体：什么时候调用自身方法 很占资源，容易卡死","categories":[],"tags":[]},{"title":"java流程控制","slug":"java流程控制","date":"2021-08-05T13:53:59.000Z","updated":"2021-08-05T13:59:56.764Z","comments":true,"path":"2021/08/05/java流程控制/","link":"","permalink":"http://example.com/2021/08/05/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"Scanner对象 顺序结构 选择结构 循环结构","text":"Scanner对象 顺序结构 选择结构 循环结构 Scanner对象java.util.Scanner Java5的新特性，可以通过Scanner类来获取用户的输入 基本语法 1Scanner s = new Scanner(System.in); 通过next()和nextLine()获取字符串 通过hasNext()和hasNextLine()判断有没有输入 属于io流如果不关闭会一直占用资源，记得scanner.close() next() 一定要读取到有效字符后才可以结束输入 对输入有效字符之前遇到的空白，next()方法会自动将其去掉 输入有效字符后，将输入的空白作为分隔符或结束符 next()不能得到带有空格的字符串 nextLine() 以Enter为结束符 可以获得空白 顺序结构最基本的默认结构，从上到下执行 选择结构 if单选择结构 123if()&#123; &#125; if双选择结构 12345if()&#123; &#125;else&#123; &#125; if多选择结构 123456789if()&#123; &#125;else if()&#123; &#125;else if()&#123; &#125;else&#123; &#125; switch多选择结构 12345678910switch()&#123; case value1: //语句 break; case value2: //语句 break; default: //语句&#125; switch语句中的变量类型可以是byte, short, int, char, String(从Java SE 7开始支持) case标签必须为字符串常量或者字面量 case没有break把后面的所有语句全执行 循环结构 while循环 1234567while()&#123; &#125;while(true)&#123;//死循环 //服务器监听响应&#125; do..while循环 123do&#123; &#125;while()//循环体至少会执行一次 for循环 1234for(初始化;布尔表达式;更新)&#123; //初始化语句可以是空语句，也可以是一种类型多个变量 //布尔表达式和更新也可以是空语句，即for(;;)&#123;&#125;是死循环&#125; 增强for循环 Java5引入的一种主要用于数组或者集合的增强型for循环 1234for(声明语句:表达式)&#123; //声明语句：声明新的局部变量，变量的类型必须和数组元素的类型匹配。作用域限定值循环语句块，其值与此时数组元素的值相等 //表达式：是要访问的数组名，或者是返回值为数组的方法&#125; break和continue break：退出整个循环 continue：退出本轮循环","categories":[],"tags":[]},{"title":"java基础语法","slug":"java基础语法","date":"2021-08-02T14:22:04.000Z","updated":"2021-08-05T16:46:37.573Z","comments":true,"path":"2021/08/02/java基础语法/","link":"","permalink":"http://example.com/2021/08/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"注释 标识符 数据类型 类型转换 变量 常量 变量命名规范 运算法 包机制 JavaDoc","text":"注释 标识符 数据类型 类型转换 变量 常量 变量命名规范 运算法 包机制 JavaDoc 注释单行注释 1//单行注释 多行注释 12345/*多行注释多行注释多行注释*/ 文档注释（JavaDoc） 1234/** *@Description HelloWorld *@Author RW */ 标识符类名，方法名，变量名都是标识符 所有标识符必须以A-Z, a-z, $, _开始 首字符之后的可以是A-Z, a-z, $, _，数字 不能用关键字 标识符大小写敏感 可以用中文，但是不建议 关键字 String不是关键字，是类 数据类型java，c++是强类型语言（所有变量必须先定义后使用） 安全性高，速度慢 js是弱类型语言 java的数据类型分为两大类 基本类型 整数类型：byte占1字节, short占2字节, int占4字节, long占8字节 long类型要在数字后面加L， long num = 30L; 浮点类型：float占4字节, double占8字节 float类型要在数字后面加F， float num = 30F; 字符类型：char占2字节 boolean类型：占1位 值只有true和false 引用类型 类 接口 数组 java中表示进制 二进制 0b 八进制 0 十六进制 0x 浮点数（float double）是离散的，有舍入误差，接近但不等于 123float f = 0.1f;//0.1double d = 1.0/10;//0,1System.out.println(f==d); //会输出false 123float d1 = 2313131323123113f;float d2 = d1 + 1;System.out.println(d1==d2); //会输出true 因此，最好避免使用浮点数进行比较 所有的字符本质还是数字 编码 Unicode 2字节 0-65536 1char c = &#x27;\\u0061&#x27;; //c输出‘a&#x27; 转义字符 \\t 制表符 \\n 换行 ……. 类型转换低—————————————————————&gt;高 byte,short,char –&gt; int –&gt; long –&gt; float –&gt; double 从低到高，占的位越来越多，且小数高于整数 强制转换 高-低 (类型)变量名 e.g. int(100) 自动转换 低-高 注意点： 不能对布尔值进行转换 不能把对象类型转换为不相干类型 再把高容量转换到低容量时，要做强制转换 转换的时候可能存在内存溢出或者精度的问题 在操作比较大的数的时候，要注意溢出 tips：JDK7新特性，大的数可以在中间加下划线方便看 比如1_0000_0000 变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域 变量作用域 类变量 实例变量：从属于对象（类）可以不初始化值，有自动初始化 数值类型初始化默认0 0.0 布尔值默认是false 除了基本变量，其余的默认值都为null(比如string) 局部变量：必须声明和初始化值 不会自动初始化 1234567public class demo&#123; static double salary = 2500;//类变量 String str = &#x27;abc&#x27;;//实例变量 public static void main(String[] args)&#123; int a = 0;//局部变量 &#125;&#125; 常量初始化后不能再改值 1static final double PI = 3.14;//常量名一般使用大写字符 tip：public，final和static都是修饰符，不存在先后顺序 变量命名规范类成员变量，局部变量：首字母小写，驼峰 常量：大写字母和下划线 MAX_VALUE 类名：首字母大写，驼峰 方法名：首字母小写，驼峰 run() 运算符算数运算符：+ - * / % ++ – (++a是先自增在赋值，a++是先赋值再自增) 赋值运算符：= 关系运算符：&gt;, &lt;, &gt;=, &lt;=, ==, !=, instanceof 逻辑运算符（与或非）：&amp;&amp; || ! 短路运算：a&amp;&amp;b 如果a已经是假的，那么不在看b 位运算符： &amp; | ^ ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; 2*8=16 可以是2&lt;&lt;3 = 16 条件运算符： ? : 扩展赋值运算符： +=, -=, *=, /= 12345678910long a = 23123123;int b= 123;short c = 10;byte d = 8;/*a+b+c+d结果是Long类型b+c+d结果是int类型c+d结果是int类型因为有long就是long，没有long就是int*/ 包机制本质就是文件夹 格式是package com.baidu.baike; 且必须在前上面 一般利用公司域名倒置作为包名 JavaDoc用来生成自己API文档 参数信息 @author作者名 @version版本号 @since指明需要最早使用的jdk版本 @param参数名 @return返回值情况 @throws异常抛出情况 生成步骤（也可以用idea之类的打开） ​ 找到java文件所在文件夹，打开cmd ​ 输入javadoc -encoding UTF-8 -charset UTF-8 Doc.java ​ 然后在文件夹中就可以找到","categories":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/categories/java-SE/"}],"tags":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/tags/java-SE/"}]},{"title":"win10下基于hexo+github搭建个人博客过程","slug":"win10下基于hexo-github搭建个人博客过程","date":"2021-08-02T12:50:31.000Z","updated":"2021-08-02T14:10:54.605Z","comments":true,"path":"2021/08/02/win10下基于hexo-github搭建个人博客过程/","link":"","permalink":"http://example.com/2021/08/02/win10%E4%B8%8B%E5%9F%BA%E4%BA%8Ehexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/","excerpt":"这个博客就是基于hexo+github所搭建的网站，在此先记录一下搭建的过程","text":"这个博客就是基于hexo+github所搭建的网站，在此先记录一下搭建的过程 Step1 安装nodejs在https://nodejs.org/上下载14.17.4LTS（我搭建时的最新版本） 下载完后直接无脑下一步安装就好。（亲测没必要装在c盘） 安装完之后，win+R调出搜索，输入cmd，打开命令行，分别输入 1node -v 1npm -v 查看是否成功安装。 Step2 安装cnpm在命令行中输入 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完之后输入 1cnpm -v 查看是否成功安装 Step3 用cnpm安装hexo框架在命令行中输入 1cnpm install -g hexo-cli 安装完之后输入 1hexo -v 查看是否成功安装 Step4 在任意位置建立空文件夹这个文件夹用于存放博客的所有内容。e.g.我的路径是E:\\study\\blog\\ Step5 进入刚刚创建的文件夹在空白处按住shift单击右键打开PowerShell窗口。在命令行中输入 1hexo init 这里注意由于我的路径是在E盘中，所以并没有管理员权限的问题，如果在c盘可能会有（我没自己试过） 初始化后进入文件夹会发现出现很多文件。 Step6 启动hexo还是在blog文件夹下打开PowerShell窗口。在命令行中输入 1hexo s 会出现提示http://localhost:4000/，在浏览器输入这个网址进入博客。Ctrl+c退出 Step7 创建文章还是在blog文件夹下打开PowerShell窗口。在命令行中输入 1hexo n &#x27;文章名字&#x27; 之后进入/source/posts，发现新出现了一个 文章名字.md 的文件。直接txt格式打开用markdown格式写文章就行。 Step8 上传文章返回blog文件夹下打开PowerShell窗口。在命令行中输入 123hexo cleanhexo ghexo s 再从http://localhost:4000/进入博客，发现文章已经上传。 Step9 将博客部署到githubhttps://github.com/登陆自己的github账号，点右上角的+，New repository 在Repository name输入 自己的github名.github.io 比如我的github叫enheng244，我就是enheng244.github.io 然后Create repository 在blog文件夹下打开PowerShell窗口。在命令行中输入 1cnpm install --save hexo-deployer-git 安装完之后，在blog文件下找到_config.yml，进入后在最底部找到#Deployment，配置如下 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/enheng244/enheng244.github.io.git branch: master repo行换成自己的github地址即可。 Step10 进入博客此时在浏览器输入enheng244.github.io即可访问自己的博客 Step11 换主题在github上或其他地方可以找到很多主题，可以按照其中的文档去换主题 Step12 常用命令1234hexo cleanhexo ghexo s hexo d","categories":[],"tags":[]},{"title":"markdown语法总结","slug":"markdown语法总结","date":"2021-08-02T10:35:12.000Z","updated":"2021-08-05T13:55:53.823Z","comments":true,"path":"2021/08/02/markdown语法总结/","link":"","permalink":"http://example.com/2021/08/02/markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"从前只是零零散散的用过一些markdown形式，既然下定决心要开始写博客了，所有最先做的先要把markdown的语法先过一遍，以后就不用再每次用的时候去一直百度。","text":"从前只是零零散散的用过一些markdown形式，既然下定决心要开始写博客了，所有最先做的先要把markdown的语法先过一遍，以后就不用再每次用的时候去一直百度。 标题一级标题（一个# + 空格 + 标题名）二级标题（二个# + 空格 + 标题名）三级标题（三个# + 空格 + 标题名）四级标题（四个# + 空格 + 标题名）五级标题（五个# + 空格 + 标题名）最多支持到六级标题（六个# + 空格 + 标题名）字体Hello.World!(粗体前后各加两个星号) Hello.World!（斜体前后各加一个星号） Hello.World!（粗体加粗体前后各加三个星号） Hello.World!（前后各加两个波浪号） 引用 前面&gt;加空格 分割线三个减号— 三个星号*** 图片感叹号中括号小括号前面写图片名后面写路径 可以是本地的也可是网上的路径 超链接点击跳转到百度 中括号小括号前面写文字后面写网址 列表有序列表： 1.空格 a b c 无序列表： -空格 a b c 表格名字|性别|生日 –|–|–| 张三|男|1997.1.1 名字 性别 生日 张三 男 1997.1.1 代码三个` （tab上面的）+ 语言，比如java + 回车 1import","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-08-01T16:52:41.360Z","updated":"2021-08-02T12:45:19.379Z","comments":true,"path":"2021/08/02/hello-world/","link":"","permalink":"http://example.com/2021/08/02/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/categories/java-SE/"}],"tags":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/tags/java-SE/"}]}