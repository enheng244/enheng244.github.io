{"meta":{"title":"BinSpace","subtitle":"subtitle待填充","description":"早日发财！","author":"Bin","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-08-05T23:42:14.000Z","updated":"2021-08-05T16:46:17.616Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-05T23:37:42.000Z","updated":"2021-08-05T16:39:56.400Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java泛型","slug":"java泛型","date":"2021-08-28T18:52:10.000Z","updated":"2021-08-28T21:42:53.325Z","comments":true,"path":"2021/08/28/java泛型/","link":"","permalink":"http://example.com/2021/08/28/java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"泛型 一. 为什么有泛型泛型：标签 1.1 举例中药店，每个抽屉外面贴着标签超市购物架上很多瓶子，每个瓶子装的是什么，有标签。 1.2 泛型的设计背景集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt; E &gt;，List&lt; E &gt;，ArrayList&lt; E &gt;，这个&lt; E &gt;就是类型参数，即泛型。 1.3 泛型的概念 所谓泛型，就是允许在定义类、接口时通过一个标识，表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。 从JDK1.5以后，Java引入了“参数化类型（Parameterizedtype）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List&lt; String &gt;，这表明该List只能保存字符串类型的对象。 JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。 二. 在集合中使用泛型2.1 在集合中使用泛型之前1234567891011121314151617public class GenericTest &#123; public void test()&#123; ArrayList list = new ArrayList(); //需求：存放学生的成绩 list.add(78); list.add(87); list.add(99); list.add(65); //问题一：类型不安全 list.add(&quot;Tom&quot;); for(Object score : list)&#123; //问题二：强转时可能出现类型转化异常 int stuScore = (Integer)score;//可能会有ClassCastException System.out.println(stuScore); &#125; &#125;&#125; 2.2 在集合中使用泛型2.2.1 ArrayList 123456789101112131415161718192021222324public void test2()&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(78); list.add(87); list.add(99); list.add(65); //编译时，就会进行类型检查，保证数据的安全 下面这样会报错 //list.add(&quot;Tom&quot;); //方式一： for(Integer score :list)&#123; //避免了强转的操作 int stuScore = score; System.out.println(stuScore); &#125; //方式二： Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; int stuScore = iterator.next(); System.out.println(stuScore); &#125; &#125;&#125; 2.2.2 HashMap12345678910111213141516171819public void test3()&#123; Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); //jdk7新特性：类型推断 后面的Hashmap&lt;&gt; 括号里不用写，默认和前面的一样 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Tom&quot;,87); map.put(&quot;Tone&quot;,81); map.put(&quot;Jack&quot;,64); //泛型的嵌套 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator(); while(iterator.hasNext())&#123; Map.Entry&lt;String, Integer&gt; e = iterator.next(); String key = e.getKey(); Integer value = e.getValue(); System.out.println(key + &quot;----&quot; + value); &#125;&#125; 三. 自定义泛型结构泛型在继承上的体现 通配符的使用 泛型应用举例 ​","categories":[],"tags":[]},{"title":"数据结构(二)","slug":"数据结构(二)","date":"2021-08-27T23:38:14.000Z","updated":"2021-08-27T19:51:07.618Z","comments":true,"path":"2021/08/28/数据结构(二)/","link":"","permalink":"http://example.com/2021/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)/","excerpt":"树","text":"树 一.二叉树1. 节点结构12345class Node&lt;V&gt;&#123; V value; Node left; Node right;&#125; 2. 用递归和非递归两种方式实现二叉树的先序、中序、后序遍历2.1 递归方式 每一个节点会被经过三次，在第一次打印信息就是先序，第二次就是中序，第三次就是后序 2.1.1 先序（深度优先遍历）12345678public static void preOrderRecur(Node head)&#123; if(head == null)&#123; return; &#125; System.out.println(head.value + &quot; &quot;); preOrderRecur(head.left); preOrderRecur(head.right);&#125; 2.1.2 中序12345678public static void inOrderRecur(Node head)&#123; if(head == null)&#123; return; &#125; inOrderRecur(head.left); System.out.println(head.value + &quot; &quot;); inOrderRecur(head.right);&#125; 2.1.3 后序12345678public static void postOrderRecur(Node head)&#123; if(head == null)&#123; return; &#125; postOrderRecur(head.left); postOrderRecur(head.right); System.out.println(head.value + &quot; &quot;);&#125; 2.2 非递归方式2.2.1 先序（深度优先遍历）12345678910111213141516public static void preOrderUncur(Node head)&#123; if(head != null)&#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); stack.push(head); while(!stack.isEmpty())&#123; head = stack.pop(); System.out.println(head.value + &quot; &quot;); if(head.right != null)&#123; stack.push(head.right); &#125; if(head.left != null)&#123; stack.push(head.left); &#125; &#125; &#125;&#125; 2.2.2 中序 每棵子树整棵树的左边界进栈，在依次弹出的过程中，打印，并将右子树弄进栈，以上操作循环 123456789101112131415public static void inOrderUncur(Node head)&#123; if(head != null)&#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while(!stack.isEmpty() || head != null)&#123; while( head != null)&#123; stack.push(head); head = head.next; &#125; else &#123; head = stack.pop(); System.out.println(head.value + &quot; &quot;); head = head.right(); &#125; &#125; &#125;&#125; 2.2.3 后序1234567891011121314151617181920public static void posOrderUncur(Node head)&#123; if(head != null)&#123; Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;(); Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;(); s1.push(head); while(!s1.isEmpty())&#123; head = s1.pop(); s2.push(head); if(head.left != null)&#123; stack.push(head.left); &#125; if(head.right != null)&#123; stack.push(head.right); &#125; &#125; while(!s2.isEmpty())&#123; System.out.println(s2.pop().value + &quot; &quot;); &#125; &#125;&#125; 3. 如何完成二叉树的宽度优先遍历1234567891011121314151617public static void w(Node head)&#123; if(head == null)&#123; return; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(head); while(!queue.isEmpty())&#123; Node cur = queue.poll(); System.out.println(cur.value); if(cur.left != null)&#123; queue.add(cur.left); &#125; if(cur.right != null)&#123; queue.add(cur.right); &#125; &#125;&#125; 常见题目：求一棵二叉树的最大宽度 用哈希表 12345678910111213141516171819202122232425262728293031323334public static int w(Node head)&#123; if(head == null)&#123; return; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(head); HashMap&lt;Node, Integer&gt; levelMap = new HashMap&lt;&gt;(); levelMap.put(head, 1); int curLevel = 1; int curLevelNodes = 0; int max = Integer.MIN_VALUE; while(!queue.isEmpty())&#123; Node cur = queue.poll(); int curNodeLevel = levelMap.get(cur); if(curNodeLevel == curLevel)&#123; curLevelNodes++; &#125; else &#123; max = Math.max(max, curLevelNodes); curLevel++; curLevelNodes = 1; &#125; if(cur.left != null)&#123; levelMap.put(cur.left, curNodeLevel+1); queue.add(cur.left); &#125; if(cur.right != null)&#123; levelMap.put(cur.left, curNodeLevel+1); queue.add(cur.right); &#125; &#125; return max;&#125; 用两个变量，当前层最后一个变量和下一层最后一个变量 4. 判断二叉树的性质1. 如果判断二叉树是否是搜索二叉树（左边小右边大）中序遍历，如果依次升序，就是搜索二叉树","categories":[],"tags":[]},{"title":"数据结构练习题","slug":"数据结构练习题","date":"2021-08-24T00:37:19.000Z","updated":"2021-08-25T14:56:42.531Z","comments":true,"path":"2021/08/24/数据结构练习题/","link":"","permalink":"http://example.com/2021/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"异或","text":"异或 一. 异或1）如果一个数组内，只有一种数字出现过奇数次，其他数字都出现偶数次，找出这个数。要求时间复杂度O(n), 空间复杂度O(1).1234567public static void demo(int[] arr)&#123; int eor = 0; for(int cur; arr)&#123; eor = eor ^ cur; &#125; System.out.println(eor);&#125; 2）如果一个数组内，只有两种数字出现过奇数次，其他数字都出现偶数次，找出这个数。要求时间复杂度O(n), 空间复杂度O(1).1234567891011121314151617public static void demo(int[] arr)&#123; int eor = 0; for(int cur; arr)&#123; eor = eor ^ cur; &#125; //此时的eor是a^b //因为ab不相同，所以eor != 0,所以eor必然有一位是1 int rightOne = eor &amp; (~eor + 1);//提取出最右的1，详细解释看下面 int onlyOne = 0; for(int cur; arr)&#123; if((cur &amp; rightOne) == 0)&#123;//区分出来a和b onlyOne ^= cur; &#125; &#125; System.out.println(onlyOne + &#x27; &#x27; + (eor ^ onlyOne));&#125; a &amp; (~a+ 1): 常用来提取最右侧的1 &amp;是与操作， ~是非操作。具体过程如下： ​ 比如a的值为 1000111100 ​ 那么~a的值为 0111000011 ​ ~a+1的值为 0111000100 ​ a &amp; (~a+ 1)为 0000000100 二. 二分法1）在一个有序数组中，找到某个数的存在。用二分法，很容易实现，时间复杂度为O($\\log_2n$)​ 2）在一个有序数组中，找到大于等于某个数(a)最左侧的位置用二分法，如果数组从小到大排列，如果切到的数大于a则往左接着切，小于a则往右接着切，直到切完 3）在一个无序且相邻数一定不相等的数组中，找到任意一个局部最小值，可以是最头或者最尾的数如果一头一尾都不是局部最小值，那么在中间一定存在局部最小值，而且从前往后走，第一个比后一个数小的数，就是一个局部最小值，这样的时间复杂度为O(n)。 但是可以用二分法，如果比前一个数大，则往左切……这样最后一定会找到一个局部最小值，时间复杂度为O($\\log_2n$)。因为切完相当于一个新的无序且相邻数一定不相等的数组。 三. 递归1）用递归找到数组中最大的数123456789public static void demo(int[] arr, int L, int R)&#123; if(L == R)&#123; return arr[L]; &#125; int mid = L + ((R - L) &gt;&gt; 1);//找中点， &gt;&gt;1是向右移一位，相当于/2，运算速度比/2快。用(R+L)/2可能会溢出 int leftMax = demo(arr, L, mid); int rightMax = demo(arr, mid + 1, R); return Math.max(leftMax, rightMax);&#125; 2）master公式当递归过程符合T(N) = a*T(N/b) + O($N^d$​)时， 情况一： $\\log_ba$ &lt; d 时，时间复杂度为O($N^d$) 情况二： $\\log_ba$ &gt; d 时，时间复杂度为O($N^{\\log_ba}$) 情况三： $\\log_ba$​ == d 时，时间复杂度为O($N^d*\\log_N$​) 3）归并排序的扩展：小合问题 要求时间复杂度O(nlogn)在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。例如数组[1,3,4,2,5]: 1左边比1小的数，没有；3左边比3小的数，1；4左边比4小的数，1、3；2左边比2小的数，1；5左边比5小的数，1、3、4、2；所以小和为1+1+3+1+1+3+4+2=16 思路：可以转化为每一个数右边有几个数比它大，然后用归并排序来做。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static int demo(int[] arr)&#123; if(arr == null || arr.length &lt;= 1)&#123; return 0; &#125; return mergeSort(arr, 0, arr.length-1);&#125;public static int mergeSort(int[] arr, int L, int R)&#123; int sum = 0; if(L==R)&#123; return 0; &#125; int mid = L + (R - L) &gt;&gt; 1 sum += mergeSort(arr, L, mid); sum += mergeSort(arr, mid + 1, R); return sum + merge(arr, L, mid, R); //return mergeSort(arr, L, mid) + mergeSort(arr, mid + 1, R) + merge(arr, L, mid, R);&#125; public static int merge(int[] arr, int L, int M, int R)&#123; int[] help = new int[R - L + 1]; int i = 0; int p1 = L; int p2 = M + 1; int res = 0; while(p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123; if(arr[p1] &lt; arr[p2])&#123; res += (R - p2 + 1) * arr[p1]; help[i++] = arr[p1++]; &#125;else&#123; help[i++] = arr[p2++]; &#125; //res += arr[p1] &lt; arr[p2] ? (R - p2 + 1) * arr[p1]: 0; //help[i++] = arr[p1] &gt;= arr[p2] ? arr[p2++] : arr[p1++]; &#125; while(p1 &lt;= M)&#123; help[i++] = arr[p1++]; &#125; while(p2 &lt;= R)&#123; help[i++] = arr[p2++]; &#125; for( i = 0; i &lt; help.length ; i++)&#123; arr[L + i] = help[i]; &#125; return res;&#125; 4）归并排序的扩展：逆序对问题在一个数组中，左边的数如果比右边的任何数大，则这两个数构成一个逆序对，请打印所有逆序对。 可以理解为要找每个数右边又多少个数比它小 和3)的代码类似 四. 堆排序1）已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。 思路：用堆排序，先建立一个小根堆，然后把前k+1个数据放入小根堆中。然后弹出头结点，这个数一定是整个数组中最小的数，然后接着把第k+2个数放入小根堆，再弹出头结点。最终的时间复杂度是O($n\\log_{}k$) 123456789101112131415public void static sortedArrDistanceLessK(int[] arr, int k)&#123; PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;();//默认是小根堆 int index = 0; for(; index &lt;= Math.min(arr.length, k); index++)&#123;//防止k是捣乱的参数，比数组长度还要长 heap.add(arr[index]); &#125; int i = 0; for(;index &lt; arr.length; i++, index++)&#123; heap.add(arr[index]); arr[i] = heap.poll(); &#125; while(!heap.isEmpty())&#123; arr[i++] = heap.poll(); &#125;&#125; 注意：类似这种的已经封装好的小根堆，只能实现进一个数(add)或者出一个数(poll)，但是并不能实现修改其中的某一项的值，这样做的时间复杂度会很高，因为黑盒不会只针对新的数据进行操作，而是要遍历所有的数据。如果有这样的需求时，需要自己手写小根堆","categories":[],"tags":[]},{"title":"数据结构(一)","slug":"数据结构(一)","date":"2021-08-24T00:01:25.000Z","updated":"2021-08-26T15:15:18.819Z","comments":true,"path":"2021/08/24/数据结构(一)/","link":"","permalink":"http://example.com/2021/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)/","excerpt":"时间复杂度 所有的排序方法 对数器 比较器","text":"时间复杂度 所有的排序方法 对数器 比较器 一. 时间复杂度 常数时间操作: 如果一个操作和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。 在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为O(f(N)) 时间复杂度O()按照算法可能遇到的最差情况估计 平均用θ() 最好情况用Ω() 二. 选择排序 O($n^2$)1. 交换值函数因为所有的排序操作都要涉及交换两个位置的值的操作，所以在最开始先将swap()方法定义好，之后就不每次再写了。 1.1 通过中间变量(更推荐)首先，最简单的肯定是通过中间变量： 12345public static void swap(int[] arr, int i, int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 1.2 通过异或操作异或：^ 如果一样则为0，如果不一样则为1，也可以说是不进位的加法。 12345public static void swap(int[] arr, int i, int j)&#123; arr[i] = arr[i] ^ arr[j];//i的值为i^j j的值为j arr[j] = arr[i] ^ arr[j];//i的值为i^j j的值为j^i^j=i arr[i] = arr[i] ^ arr[j];//i的值为i^j^i=j j的值为i&#125; 但是要注意，在数组中i位置不能等于j位置，否则会把自己的值弄成0. 2. 过程图 3. 具体代码123456789101112public static void selectionSort(int[] arr)&#123; if(arr == null || arr.length &lt; 2)&#123; return; &#125; for(int i = 0; i &lt; arr.length - 1; i++)&#123; int minIndex = i; for(int j = i + 1; j &lt; arr.length; j++)&#123; minIndex = arr[minIndex] &lt; arr[j] ? minIndex : j; &#125; swap(arr, i, minIndex);//交换顺序 &#125;&#125; 三. 冒泡排序 O($n^2$)1. 过程图 2. 具体代码123456789101112public static void bubbleSort(int[] arr)&#123; if(arr == null || arr.length &lt; 2)&#123; return; &#125; for(int e = arr.length - 1; e &gt;0 ; e--)&#123; for(int i = 0; i &lt; e ; i++)&#123; if(arr[i] &gt; arr[i+1])&#123; swap(arr, i, i+1); &#125; &#125; &#125;&#125; 四. 插入排序 O($n^2$​​) 只是最坏情况是$n^2$​​,因此要略好于冒泡和选择排序 1. 过程图 2. 具体代码12345678910public static void insertionSort&#123; if(arr == null || arr.length &lt;2)&#123; return; &#125; for(int i = 1; i &lt; arr.length; i++)&#123; for(int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j+1]; j--)&#123; swap(arr, j+1, j); &#125; &#125;&#125; 五. 归并排序 O($n\\log_{}n$​) 空间复杂度O(n​）1. 过程图 2. 具体代码12345678910111213141516171819202122232425262728293031323334353637public class MergeSort&#123; public static void mergeSort(int[] arr)&#123; if(arr == null || arr.length &lt;= 1)&#123; return; &#125; process(arr, 0, arr.length - 1) &#125; public static void process(int[] arr, int L, int R)&#123; if(L==R)&#123; return; &#125; int mid = L + ((R - L) &gt;&gt; 1); process(arr, L, mid); process(arr, mid + 1, R); merge(arr, L, mid, R); &#125; public static void merge(int[] arr, int L, int M, int R)&#123; int[] help = new int[R-L+1]; int i = 0; int p1 = L; int p2 = M + 1; while(p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123; help[i++] = arr[p1] &gt; arr[p2] ? arr[p2++] : arr[p1++]; &#125; while(p1 &lt;= M)&#123; help[i++] = arr[p1++]; &#125; while(p2 &lt;= R)&#123; help[i++] = arr[p2++]; &#125; for( i = 0; i &lt; help.length ; i++)&#123; arr[L + i] = help[i]; &#125; &#125;&#125; 六. 快速排序 O($n\\log_{}n$) 空间复杂度O($\\log_{}n$）1. 理解过程1.1 引入问题一：给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(n) 定一个指针从头开始遍历 如果某一项的值&lt;=num，将这一项和小于等于区的下一个数进行交换，小于等于区右扩一位，指针后移一位。 如果某一项的值&gt;num，仅将指针后移一位 直到指针走完数组，遍历停止 1.2 引入问题二（荷兰国旗问题）：给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，把等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(n​) 定一个指针从头开始遍历 如果某一项的值&lt;num，将这一项和小于区的下一个数进行交换，小于等于区右扩一位，指针后移一位。 如果某一项的值=num，仅将指针后移一位 如果某一项的值&gt;num，将这一项和大于区的前一个值交换，大于区左扩一位，指针原地不动 直到指针和大于区左边界相遇，遍历停止 1.3 快排1.0——由问题一得来 时间复杂度O($n^2$) 取数组的最后一个元素作为基准(问题一中的num)，将小于等于这个数的项放在左边，大于这个数的项放在右边，得到左右两个子数组。 分别取左右两个子数组的最后一个元素作为基准，再按步骤一进行分组。 递归，直到全部有序 1.4 快排2.0——由问题二得来 时间复杂度O($n^2$) 取数组的最后一个元素作为基准(问题一中的num)，将小于这个数的项放在左边，将等于这个数的项放在中间，大于这个数的项放在右边，得到左右两个子数组。（中间全是相等的项的组认为已经是排好的组，就不再动） 分别取左右两个子数组的最后一个元素作为基准，再按步骤一进行分组。 递归，直到全部有序 但是，如果数组已经有序时（即最坏情况），此时的时间复杂度是O($n^2$​​)，而根据master公式，如果每次分组都正好平分，则时间复杂度为O($n\\log_{}n$​)​​。划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低 1.5 快排3.0——随机选择基准数 时间复杂度O($n\\log_{}n$) 空间复杂度O($\\log_{}n$）即不再用固定的项来当基准数，而是再数组中随机选择一个数，其他操作与快排2.0基本相同，这样做，长期期望会是O($n\\log_{}n$) 2. 具体代码12345678910111213141516171819202122232425262728293031public static void quickSort(int[] arr)&#123; if(arr == null || arr.length &lt; 2)&#123; return; &#125; quickSort(arr, 0, arr.length -1);//注意是重载&#125;public static void quickSort(int[] arr, int L, int R)&#123; if(L &lt; R)&#123; swap(arr, L + (int) (Math.random() * (R - L + 1)), R);//随机选择一项和最后一位交换 int[] p = partition(arr, L, R);//p中只有两项，第一项是等于区的左边界，第二项是等于区的右边界 quickSort(arr, L, p[0] - 1); //小于区 quickSort(arr, p[1] + 1, R); //大于区 &#125;&#125;public static int[] partition(int[] arr, int L, int R)&#123; int less = L - 1;//小于区的右边界 int more = R;//大于区的左边界 while(L &lt; more)&#123;//L代表指针位置 if(arr[L] &lt; arr[R])&#123;//arr[R]是基准值 swap(arr, ++less, L++); &#125; else if(arr[L] &gt; arr[R])&#123; swap(arr, --more, L); &#125; else &#123; L++; &#125; &#125; swap(arr, more, R);//最后不要忘记把最后的基准值移动中间 return new int[]&#123; less + 1, more&#125;;//返回等于区的左右边界&#125; 七. 堆排序 O($n\\log_{}n$) 空间复杂度O(1)1. 堆结构 堆结构就是用数组实现的完全二叉树结构 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆 1.1找父与子树父: （i-1)/2 向下取整 左子：2 * i + 1 右子：2 * i + 2 1.2 heapInsert操作 O($\\log_{}n$) 举例场景：新向大根堆中加入了一个元素 123456public static void haeapInsert(int[] arr, int index)&#123;//index是新项的下标 while(arr[index] &gt; arr[(index - 1) / 2])&#123;//新加入的项比父大 swap(arr, index, (index - 1) / 2);//新项与父交换位置 index = (index - 1) / 2;//index指向新项新的位置（原来父节点的位置） &#125;&#125; 1.3 heapify操作 O($\\log_{}n$​) 举例场景：大根堆中的头结点被删除，将最后一位元素复制到头结点的位置，heapSize—，然后从头结点往下比 12345678910111213public static void heapify(int[] arr, int idnex, int heapSize)&#123; int left = index * 2 + 1;//左孩子的下标 while(left &lt; heapSize)&#123;//还有左孩子时 int largest = left + 1 &lt; heapSize &amp;&amp; arr[left+1] &gt; arr[left] ? left + 1 : left;//找到左右孩子里最大的 largest = arr[largest] &gt; arr[index] ? largest : index;//最大的孩子和父节点比大小 if(largest == index)&#123; break; &#125; swap(arr, index, largest); index = largest; left = index * 2 + 1; &#125;&#125; 2. 堆排序2.1 大致步骤 先创建一个heapsize=0的大根堆 将数组的每一项挨个放进大根堆，用heapInsert，直到整个数组变成大根堆 heapSize==数组的长度 将第一个元素（大根堆的头结点，即数组的最大值）和最后一个元素交换位置，heapSize— 从头结点做heapify 按照3,4步一直完成排序 2.2 具体代码123456789101112131415public static void heapSort(int[] arr)&#123; if(arr == null || arr.length &lt; 2)&#123; return; &#125; for (int i = 0; i &lt; arr.length; i++)&#123; heapInsert(arr, i); &#125; int heapSize = arr.length; swap(arr, 0, --heapSize); while(heapSize &gt; 0)&#123; heapify(arr, 0, heapSize); swap(arr, 0, --heapSize); &#125; &#125; 2.3 扩展1. 在5-7行，将一个数组转换为大根堆时，时间复杂度可以由 O($n\\log_{}n$​)降低到O(n).123for (int i = arr.length - 1; i &gt;= 0; i--)&#123; heapify(arr, i, arr.length);//从最后一项倒着向前做heapify&#125; 这一操作的时间复杂度的大致证明：完全二叉树最下面一层大致有N/2个节点，倒数第二层大致有N/4个节点，倒数第三层大致有N/8个节点，以此类推，而最下面一层进行heaptify操作数为1，倒数第二层为2，倒数第三次为3，以此类推。所以总操作数为：T(n) = N/2 1 + N/4 2 + N/8 * 3 + …… 然后等式左右两边同时乘2然后错位相减，得到T(N) = N + N/2+ N/4+ N/8 + …… 的等比数列，可得时间复杂度为O(N) 但是由于第10-13行的操作的时间复杂度仍然是O($n\\log_{}n$)，所以堆排序总体的时间复杂度仍然不变 2. 优先级队列结构，就是堆结构而不是队列结构（认为堆顶的优先级最高）八. 桶排序 O(n) 空间复杂度O(M) 此前的所有排序方法都是基于比较的排序，这个不是。但是这种方法应该范围不广，跟数据状况有关 1.计数排序比如数组中的数据是人的年龄，那么可以确定所有元素都在0和200之间。因此建立一个长度为200数组，每一项是原数组中每个数字出现的个数，然后直接根据新数组得到排序好的数组。 2.基数排序2.1 过程图 2.2 具体代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void radixSort(int[] arr)&#123; if(arr == null || arr.length &lt; 2)&#123; return; &#125; radixSort(arr, 0, arr.length - 1, maxbits(arr));&#125;public static int maxbits(int[] arr)&#123;//得出最大的数有多少位，并返回位数 int max = Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++)&#123;//找最大值 max = Math.max(max, arr[i]); &#125; int res = 0; while(max != 0)&#123; res++; max /= 10; &#125; return res;&#125;public static void radixSort(int[] arr, int L, int R, int digit)&#123; final int radix = 10;//10进制 int i = 0, j = 0; int[] bucket = new int[R - L + 1];//有多少个数准备多少个辅助空间 for(int d = 1; d &lt;= digit; d++)&#123;//有多少位就有多少次出桶入桶 int[] count = new int[radix];//count[i]代表当前位（d位）是0~i的数字有多少个 for(i = L; i &lt;= R; i++)&#123;//遍历整个数组 j = getDigit(arr[i], d);//j代表当前元素d位的数字 count[j]++;//计数 &#125; for(i = 1; i &lt; radix; i++)&#123; count[i] = count[i] + count[i-1]; &#125; for(i = R; i &gt;= L; i--)&#123;//倒着遍历 j = getDigit(arr[i], d); bucket[count[j] - 1] = arr[i]; count[j]--; &#125; for(i = L, j = 0; i &lt;= R; i++. j++)&#123; arr[i] = bucket[j]; &#125; &#125;&#125;public static int getDigit(int x, int d)&#123; return ((x / ((int) Math.pow(10, d-1))) % 10);&#125; 九. 排序的总结 基于选择的排序 时间复杂度 空间复杂度 稳定性 选择排序 O($n^2$) O(1) × 冒泡排序 O($n^2$) O(1) √ 插入排序 O($n^2$) O(1) √ 归并排序 O($n\\log_{}n$) O(n) √ 快速排序 O($n\\log_{}n$) O($\\log_{}n$） × 堆排序 O($n\\log_{}n$) O(1) × 稳定性：同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的，否则就没有。（桶排序思想下的排序都有稳定性） 结论： 实验证明，快速排序最快 堆排序，额外空间少 归并排序，有稳定性 基于比较的排序，时间复杂度在O($n\\log_{}n$) 以下的方法还没被发现 时间复杂度O($n\\log_{}n$​) 的方法，空间复杂度在O(n)以下，还能做到稳定的方法还没发现 常见的坑： “归并排序 内部缓存法”：归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，但是这样做就不再具有稳定性，和堆排序的性质就类似了，因此在实际中没有必要。 “原地归并排序”：归并排序的额外空间复杂度可以变成O(1)，但是会让归并排序的时间复杂度变成O($n^2$​) 论文“01 stable sort”：快速排序可以做到稳定性，但是非常难，不需要掌握，但是会让空间复杂度变成O(n)，和归并的性质类似，因此在实际中没有必要。 所有的改进都不重要，因为目前没有找到时间复杂度O($n\\log_{}n$) ，空间复杂度在O(n)，又稳定的排序 题目：是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，要求空间复杂度O(1)，时间复杂度O(n)。 解：因为快速排序的partition过程可以类比成分成奇数偶数两组，这个过程是n和1的复杂度，但是做不到稳定，所以这个也不行，除非像论文“01 stable sort”一样 工程上对排序的优化： 1) 充分利用O($n\\log_{}n$) 和O($n^2$)排序各自的优势，进行综合排序（下面5-9行） 1234567891011121314public static void quickSort(int[] arr, int L, int R)&#123; if(L = R)&#123; return; &#125; if(L &gt; R - 60)&#123; //进行插入排序 //O(n^2) 小样本量的时候跑得快 因为常数项低 return; &#125; swap(arr, L + (int) (Math.random() * (R - L + 1)), R); int[] p = partition(arr, L, R); quickSort(arr, L, p[0] - 1); quickSort(arr, p[1] + 1, R);&#125; 稳定性的考虑——对于基础类型不用考虑稳定性，对于非基础类型要考虑稳定性 十. 对数器的概念和使用 有一个你想要测的方法a 实现复杂度不好但是容易实现的方法b 实现一个随机样本产生器（比如生成随机长度随机数据的数组） 把方法a和方法b跑相同的随机样本，看看得到的结构是否一样 如果有一个随机样本使得比对结构不一致，打印样本进行人工干预，改对方法a或者方法b 当样本数量很多时，比对测试依然正确，可以确实方法a已经正确 十一. 比较器相当于重载比较运算符 123456789101112131415161718192021222324252627282930public class Comparator&#123; public static class Student&#123; public String name; public int id; public int age; public Student(String name, int id, int age)&#123; this.name = name; this.id = id; this.age = age; &#125; &#125; public static class IdAscendingComparator implements Comparator&lt;Student&gt;&#123;//比较器 //返回负数的时候，第一个参数排在前面 //返回正数的时候，第二个参数排在前面 //返回0的时候，谁在前面无所谓 @Override public int compare(Student o1, Student o2)&#123; return o1.id - o2.id; &#125; &#125; public static void main(String[] args)&#123; Student student1 = new Student(&quot;A&quot;, 2, 20); Student student2 = new Student(&quot;B&quot;, 3, 21); Student student3 = new Student(&quot;C&quot;, 1, 22); Student[] students = new Student[]&#123;student1, student2, student3&#125;; Arrays.sort(students, new IdAscendingComparator()); &#125;&#125; 十二. 哈希表1）哈希表在使用层面上可以理解为一种集合结构 2）如果只有key，没有伴随数据value，可以使用HashSet结构 3）如果既有key，又有伴随数据value，可以使用HashMap结构 4）有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事 5）使用哈希表增（put）删（remove）改（put）查（get）的操作，可以认为时间复杂度为O(1)，但是常数时间比较大 6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小 7）放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小（8字节） 十三. 有序表1）有序表在使用层面上可以理解为一种集合结构 2）如果只有key，没有伴随数据value，可以使用TreeSet结构 3）如果既有key，又有伴随数据value，可以使用TreeMap结构 4）有无伴随数据，是TreeMap和TreeSet唯一的区别，底层的实际结构是一回事 5）有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织 6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小 7）放入哈希表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用的是这个东西内存地址的大小 8）不管是什么底层具体实现，只要是有序表，都有以下固定的功能和固定的时间复杂度 put get remove containsKey firstKey lastKey floorKey ceilingKey 以上所有的操作时间复杂度都是O($\\log_{}n$)，n为有序表含有的记录数 9）红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同","categories":[],"tags":[]},{"title":"单链表","slug":"单链表","date":"2021-08-17T23:12:08.000Z","updated":"2021-08-26T15:15:14.618Z","comments":true,"path":"2021/08/18/单链表/","link":"","permalink":"http://example.com/2021/08/18/%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"单链表","text":"单链表 存储结构链表在内存中的存储实际结构： 链表是以节点的方式来存储，是链式存储 每个节点包含 data 域 和 next 域。next域用来指向下一个节点 如图所示，链表的各个节点不一定是连续存储的 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 单链表（带头结点）逻辑结构： 实现思路（添加）创建 先创建一个Head头节点，表示单链表的头，头结点不存放具体数据，作用就是表示单链表的头 后面我们每添加一个节点，就放在链表的最后 遍历 通过一个辅助变量，来遍历整个链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class HeroNode&#123; public int no; public String name; public String nickName; public HeroNode next; public HeroNode(int no, String name, String nickname)&#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString()&#123; return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot; &#125;&#125;//定义SingleLinkedList管理链表class SingleLinkedList&#123; //初始化头结点 private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;); //添加节点到末尾 public void add(HeroNode heroNode)&#123; HeroNode temp = head; while(true)&#123; if(temp.next == null)&#123; break; &#125; temp = temp.next; &#125; temp.next = heroNode; &#125; //遍历链表 public void list()&#123; if(temp.next == null)&#123; System.out.println(&quot;空链表&quot;); return; &#125; HeroNode temp = head.next; while(true)&#123; if(temp.next == null)&#123; break; &#125; System.out.println(temp); temp = temp.next; &#125; &#125;&#125;public class SingleLinkedListTest&#123; public static void main(String[] args)&#123; HeroNode hero1 = new HeroNode(1, &quot;松江&quot;, &quot;及时雨&quot;); HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;); HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;); HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;); SingleLinkedList singleLinkedList = new SingleLinkedList(); singleLinkedList.add(hero1); singleLinkedList.add(hero2); singleLinkedList.add(hero3); singleLinkedList.add(hero4); singleLinkedList.list(); &#125;&#125; 常用技巧（部分根据labuladong公众号整理）求单链表中有效节点的个数123456789101112public int getLength(ListNode l1)&#123; if(head.next == null)&#123; return 0; &#125; int length = 0; ListNode cur = head.next; while(cur != null)&#123; length++; cur = cur.next; &#125; return length;&#125; 找单链表中倒数第k个节点123456789101112131415161718192021222324```### 单链表的反转### 倒着打印单链表（反向遍历和Stack栈）### 寻找单链表的中点### 判断单链表是否包含环并找出环起点### 判断两个单链表是否相交并找出交点### 合并两个有序链表Leetcode21题：![合并单链表1](合并单链表1.jpg)```javaListNode mergeTwoLists(ListNode l1, ListNode l2)&#123; &#125; 合并k个有序链表面试时链表解题的方法论1）对于笔试，不用太在乎空间复杂度，一切为了时间复杂度 2）对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法 重要技巧： 1）额外数据结构记录（哈希表等各种容器） 2）快慢指针（找中点）","categories":[],"tags":[]},{"title":"java枚举类和注解","slug":"java枚举类和注解","date":"2021-08-16T16:40:25.000Z","updated":"2021-08-16T21:35:20.153Z","comments":true,"path":"2021/08/16/java枚举类和注解/","link":"","permalink":"http://example.com/2021/08/16/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/","excerpt":"自定义枚举类 enum定义枚举类 注解 自定义注解 4个元注解 可重复注解 类型注解","text":"自定义枚举类 enum定义枚举类 注解 自定义注解 4个元注解 可重复注解 类型注解 枚举类 类的对象只有有限个，确定的。我们称此类为枚举类 比如：星期：星期一、….、星期日 季节：春天 夏天 秋天 冬天 当需要定义一组常量时，强烈建议使用枚举类 如果枚举类只一个对象，则可以作为单例模式的实现方式 自定义枚举类 JDK5.0之前12345678910111213141516171819202122232425262728293031323334353637383940class Season&#123; // 1.声明Season对象的属性：private final修饰 private final String seasonName; private final String seasonDesc; // 私有化的构造器，并给对象赋值 private Season(String seasonName, String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; // 3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;); public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; + &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;public class SeasonTest &#123; public static void main(String[] args) &#123; Season autumn = Season.AUTUMN; System.out.println(autumn); // Season&#123;seasonName=&#x27;秋天&#x27;, seasonDesc=&#x27;秋高气爽&#x27;&#125; &#125;&#125; 使用enum关键字定义枚举类 JDK5.0之后说明：定义的枚举类默认继承于java.lang.Enum类（toString默认是输出对象名，比如SUMMER） 12345678910111213141516171819202122232425262728293031323334// 使用enum关键字枚举类enum Season1&#123; // 1.提供当前枚举类的对象，多个对象之间用“,”隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;); // 2.声明Season对象的属性：private final修饰 private final String SeasonName; private final String SeasonDesc; // 3.私有化构造器，并给对象赋值 private Season1(String SeasonName, String SeasonDesc)&#123; this.SeasonName = SeasonName; this.SeasonDesc = SeasonDesc; &#125; // 4.获取枚举类对象的属性 public String getSeasonName() &#123; return SeasonName; &#125; public String getSeasonDesc() &#123; return SeasonDesc; &#125;&#125;public class SeasonTest2 &#123; public static void main(String[] args) &#123; Season1 season = Season1.AUTUMN; System.out.println(season); // AUTUMN &#125;&#125; enum类的常用方法 value(): 返回所有的枚举类对象的构成的数组。可以很方便地遍历所有的枚举值 valueOf(String str): 可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象 toString(): 返回当前枚举类对象常量的名称 12345678910111213141516public class SeasonTest1&#123; public static void main(String[] args)&#123; Season1 summer = Season1.SUMMER; //toString() System.out.println(summer);//SUMMER //values() Season1[] values = Season1.values(); for( int i = 0; i &lt; value.length; i++)&#123; System.out.println(values[i]);//SPRING SUMMER AUTUMN WINTER &#125; //valueOf(String str) //如果没有str的枚举类对象，则抛异常：IllegalArgumentException Season1 winter = Season1.valueOf(&quot;WINTER&quot;); System.out.println(winter); &#125;&#125; 使用enum关键字定义的枚举类实现接口的情况情况一：实现接口，在enum类中实现抽象方法12345678910111213141516171819202122232425262728293031323334353637interface Info&#123; void show();&#125;// 使用enum关键字枚举类enum Season1&#123; // 1.提供当前枚举类的对象，多个对象之间用“,”隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;); // 2.声明Season对象的属性：private final修饰 private final String SeasonName; private final String SeasonDesc; // 3.私有化构造器，并给对象赋值 private Season1(String SeasonName, String SeasonDesc)&#123; this.SeasonName = SeasonName; this.SeasonDesc = SeasonDesc; &#125; // 4.获取枚举类对象的属性 public String getSeasonName() &#123; return SeasonName; &#125; public String getSeasonDesc() &#123; return SeasonDesc; &#125; @Override public void show()&#123; System.out.println(&quot;这是一个季节&quot;); &#125;&#125; 情况二：让枚举类的对象分别实现接口中的抽象方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455interface Info&#123; void show();&#125;// 使用enum关键字枚举类enum Season2 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;春天在那里&quot;); &#125; &#125;, SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;宁夏&quot;); &#125; &#125;, AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;秋天不回来&quot;); &#125; &#125;, WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;大约在冬季&quot;); &#125;; &#125;; private final String SeasonName; private final String SeasonDesc; private Season2(String SeasonName , String SeasonDesc)&#123; this.SeasonName = SeasonName; this.SeasonDesc = SeasonDesc; &#125; public String getSeasonName() &#123; return SeasonName; &#125; public String getSeasonDesc() &#123; return SeasonDesc; &#125; @Override public String toString() &#123; return &quot;Season2&#123;&quot; + &quot;SeasonName=&#x27;&quot; + SeasonName + &#x27;\\&#x27;&#x27; + &quot;, SeasonDesc=&#x27;&quot; + SeasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 注解（Annotation）注解的理解 从JDK5.0开始，Java增加了对元数据（MetaData）的支持，也就是注解 Annotation其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在Annotation的”name=value”对中。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架=注解 + 反射 + 设计模式。 常见的Annotation示例 使用Annotation 时要在其前面增加@ 符号, 并把该Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 示例一：生成文档相关的注解 @author标明开发该类模块的作者，多个作者之间使用逗号分割 @version标明该类模块的版本 @see参考转向，也就是相关主题 @since从哪个版本开始增加的 @param对方法中某参数的说明，如果没有参数就不能写 @return对方法返回值的说明，如果方法的返回值类型是void就不能写 @exception对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出的异常就不能写 其中 @param @return和 @exception这三个标记都是只用于方法的。@param的格式要求：@param 形参名 形参类型 形参说明@return的格式要求：@return 返回值类型 返回值说明@exception的格式要求：@exception 异常类型 异常说明@param 和 @exception可以并列多个 示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择（源码里有很多） @SuppressWarnings: 抑制编译器警告 e.g. @SuppressWarnings({ “unused”, “rawtypes” }) 示例三：跟踪代码依赖性，实现替代配置文件功能（在框架中） Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。 spring框架中关于“事务”的管理 如何自定义注解：参照@SuppressWarnings定义 定义新的Annotation类型使用@interface关键字 自定义注解自动继承了java.lang.annotation.Annotation接口 Annotation的成员变量在Annotation定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、或以上所有类型的数组。 可以在定义Annotation的成员变量时为其指定初始值,指定成员变量的初始值可使用default关键字 如果只有一个参数成员，建议使用参数名为value 如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名=参数值”，如果只有一个参数成员，且名称为value，可以省略“value=” 没有成员定义的Annotation称为标记; 包含成员变量的Annotation称为元数据Annotation注意：1. 自定义注解必须配上注解的信息处理流程（使用反射）才有意义 ​ 2. 如果注解有成员，在使用注解时，需要指明成员的值 ​ 3. 自定义注解通常都会指明两个元注解：Retention和Target 1234public @interface MyAnnotation &#123; String value();//比如用@MyAnnotation(value = &quot;hello&quot;) //可以是String value() default &quot;hello&quot;; 可以用@MyAnnotation()&#125; JDK中4个基本的元注解的使用 元注解：其他注解的注解 JDK 的元Annotation 用于修饰其他Annotation 定义 JDK5.0提供了4个标准的meta-annotation类型，分别是： Retention: 只能用于修饰一个Annotation定义, 用于指定该Annotation 的生命周期, @Rentention包含一个RetentionPolicy类型的成员变量, 使用@Rentention时必须为该value成员变量指定值: RetentionPolicy.SOURCE: 在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释（即在.class文件中不会保留此注解） RetentionPolicy.CLASS: 在class文件中有效（即class保留），当运行Java 程序时, JVM 不会保留注解。这是默认值 RetentionPolicy.RUNTIME: 在运行时有效（即运行时保留），当运行Java 程序时,JVM 会保留注释。程序只有这样才可以通过反射获取该注释。 Target: 用于修饰Annotation 定义, 用于指定被修饰的Annotation 能用于修饰哪些程序元素。@Target 也包含一个名为value 的成员变量 Documented（出现频率较低）: 用于指定被该元Annotation 修饰的Annotation 类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的。 定义为Documented的注解必须设置Retention值为RUNTIME。 Inherited（出现频率较低）:被它修饰的Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的Annotation, 则其子类将自动具有该注解。 比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解 实际应用中，使用较少 JDK8中注解的新特性可重复注解① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 类型注解 JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个: TYPE_PARAMETER,TYPE_USE。 在Java8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方。 ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。","categories":[],"tags":[]},{"title":"java多线程","slug":"java多线程","date":"2021-08-14T01:36:13.000Z","updated":"2021-08-15T20:34:21.374Z","comments":true,"path":"2021/08/14/java多线程/","link":"","permalink":"http://example.com/2021/08/14/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"线程的创建和使用 线程的声明周期 线程的同步 线程的通信 sleep()和wait()的异同 Callable接口 线程池","text":"线程的创建和使用 线程的声明周期 线程的同步 线程的通信 sleep()和wait()的异同 Callable接口 线程池 程序、进程、线程 程序：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有自身的产生、存在和消亡的过程（生命周期）。进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。 线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。一个进程同时并行执行多个线程，就是支持多线程的。线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小。一个进程的多个线程共享相同的内存单元/内存地址空间（它们从同一堆中分配对象，可以访问相同的变量和对象）。这就使得线程间通信更简便高效。但多个线程操作共享的系统资源就可能会带来安全的隐患。 栈每个线程独有 方法区和堆每个进程共享 单核多核CPU 单核CPU：假的多线程。在同一时间只能跑一个线程 多核CPU：几个单核组合起来 一个java.exe 至少有三个线程：main()主线程 gc()垃圾回收线程，异常处理线程 并行与并发 并行：多个CPU同时执行多个任务，比如多个人同时做不同的事 并发：一个CPU同时执行多个任务之间切换（显得同时执行） 多线程程序的优点 提高应用程序的响应。对图形化界面更有意义，可增强用户体验 提高计算机系统CPU的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 何时需要多线程 程序需要同时执行两个或多个任务 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。 需要一些后台运行的程序时 线程的创建（2种）和使用方式一：继承于Thread类 创建一个继承于Thread类的子类 重写Thread类的run() —&gt; 将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start(): 启动当前线程 调用当前线程的run() 1234567891011121314151617181920public MyThread extends Thread&#123; @Override public void run()&#123; for( int i = 0; i &lt; 100; i++)&#123; System.out.println(i); &#125; &#125;&#125;public class ThreadTest&#123; public static void main(String[] args)&#123; MyThread t1 = new MyThread(); t1.start();//如果写t1.run()则只是调用了run方法而不是开启新的线程 //也可以这样创建Thread类的匿名子类 //new Thread()&#123; // //代码 //&#125;.start(); &#125;&#125; 注意： 不能通过直接调用run()的方式来启动线程 不可以让已经start()的线程去重新启动，如果想再调用则要重新创建一个线程的对象 Thread类的有关方法 void start(): 启动线程，并执行对象的run()方法 run(): 线程在被调度时执行的操作 String getName(): 返回该线程的名称 void setName(String name): 设置该线程的名称 12345678910public class Demo&#123; public static void main(String[] args)&#123; MyThread t1 = new MyThread(); t1.setName(&#x27;t1&#x27;);//要在start之前设置名字 h1.start(); //给主线程命名 THread.currentThread().setName(&#x27;主线程&#x27;); System.out.println(Thread.currentThread().getName()); &#125;&#125; static Thread currentThread(): 返回执行当前代码的线程。在Thread子类中就是This，通常用于主线程和Runnable实现类 static void yield(): 线程让步 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 若队列中没有同优先级的线程，忽略此方法 join(): 当某个程序执行流中调用其它线程的join()方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完为止 低优先级的线程也可以获得执行 static void sleep(long millis): (指定时间：毫秒) 令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队 抛出InterruptedException异常 stop(): 强制线程生命期结束，不推荐使用 boolean isAlive(): 返回boolean，判断线程是否还活着 方式二 实现Runnable接口 创建一个实现了Runnable接口的类 实现类去实现Runnable中的抽象方法:run() 创建实现类的对象 将此对象作为参数传递到THread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 12345678910111213141516public class MyThread implements Runnable&#123; @Override public void run()&#123; System.out.println(&quot;111&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread); t1.start(); Thread t2 = new Thread(myThread); t2 .start(); &#125;&#125; 两次方式的对比在开发中，优先选择Runnable接口的方式 原因：1. 实现的方式没有类的单继承性的局限性 ​ 2. 实现的方式更适合来处理多个线程共享数据的情况（因为本质上只创建了一个对象） 联系：继承的Thread类其实implements了Runnable接口 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中 线程的调度 调度策略 时间片：各个线程间来回切换 抢占式：高优先级的线程抢占cpu Java的调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的优先级 MAX_PRIORITY: 10 MIN_PRIORITY: 1 NORM_PRIORITY: 5 （默认） 涉及的方法 getPriority(): 返回线程优先值 setPriority(int newPriority): 改变线程的优先级 12345678910public class Demo&#123; public static void main(String[] args)&#123; MyThread t1 = new MyThread(); Thread.currentThread().setPriority(Thread.MIN_PRIORITY);//该主线程的优先级 h1.start(); //给主线程命名 THread.currentThread().setName(&#x27;主线程&#x27;); System.out.println(Thread.currentThread().getName()); &#125;&#125; 说明 线程创建时继承父线程的优先级 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用 线程的生命周期 JDK中用Thread.State类定义了线程的几种状态，在一个完整的生命周期中通常要经历如下的五种状态： 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被认为挂起或执行输入输出操作时，让出CPU并临时终止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地终止或出现异常导致结束 线程的同步（2+1方式）在java中，通过同步机制来解决线程的安全问题 方式一：同步代码块12345678synchronized(同步监视器)&#123; //需要被同步的代码（操作共享数据的代码） //共享数据：多个线程共同操作的变量&#125;//同步监视器，俗称 锁。任何一个类的对象，都可以充当锁。 要求：多个线程必须要公用同一把锁//好处：同步的方式，解决了线程的安全问题//坏处：操作同步代码时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低 处理继承Thread类线程安全问题12345678910111213141516171819202122232425262728293031323334353637383940class Window2 extends Thread&#123; //共享数据 private static int ticket = 100; @Override public void run()&#123; //添加同步代码块 // Class clazz =Window2.class,其中Window2.class只会加载一次 while(true)&#123; synchronized(Window2.class)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName()+&quot;:卖票,票号为:&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class Window2Test &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 补充：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类当同步监视器 处理实现Runnable接口123456789101112131415161718192021222324252627282930313233343536class Window1 implements Runnable&#123; //总票数 private int ticket = 100; @Override public void run() &#123; while(true)&#123; //设置同步代码块 // 此时的this：唯一的Window1的对象 synchronized(this)&#123; if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:卖票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w1 = new Window1(); Thread t1 = new Thread(w1); Thread t2 = new Thread(w1); Thread t3 = new Thread(w1); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this来充当同步监视器 方式二：同步方法如果操作共享数据的代码完整的声明在一个方法中，我们不妨碍将此方法声明同步的 处理继承Thread类线程安全问题123456789101112131415161718192021222324252627282930313233343536class Window3 extends Thread&#123; private static int ticket = 100; @Override public void run()&#123; while(true)&#123; show(); &#125; &#125; private static synchronized void show()&#123; //同步监视器：Window3.class //private synchronized void show()&#123;同步监视器：t1 t2 t3，这种方法是错误的 if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;：卖票，票号为：&quot;+ticket); ticket--; &#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w1 = new Window3(); Window3 w2 = new Window3(); Window3 w3 = new Window3(); w1.setName(&quot;窗口一&quot;); w2.setName(&quot;窗口二&quot;); w3.setName(&quot;窗口三&quot;); w1.start(); w2.start(); w3.start(); &#125;&#125; 处理实现Runnable接口1234567891011121314151617181920212223242526272829303132class Window4 implements Runnable&#123; private int ticket = 100; @Override public void run() &#123; while (true)&#123; show(); &#125; &#125; private synchronized void show()&#123; //同步监视器:this if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;:卖票，票号为：&quot;+ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 w = new Window4(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 两种方法的总结 同步方法仍然涉及到同步监视器只是不需要我们显示的声明。 非静态的同步方法，同步监视器是：this 静态的同步方法，同步监视器是: 当前类本身 死锁 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 解决方法 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 方式三：Lock锁 ——JDK5.0新增 从JDK5.0开始，java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentranLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentranLock，可以显式加锁、释放锁 如果用继承Thread类，记得lock对象加static 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Window5 implements Runnable&#123; // 1.实例化ReentrantLock ReentrantLock lock = new ReentrantLock(); private int ticket = 100; @Override public void run() &#123; while(true)&#123; try &#123; // 2. 调用锁定方法lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;：售票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125; finally &#123; // 3.调用解锁方法:unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window5 w = new Window5(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; Lock和synchronized的异同： Lock是显式锁（手动开启lock()和手动关闭锁unlock()），synchronized是隐式锁，出了作用域自动释放锁 Lock只有代码块锁，synchronized有代码锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 使用的优先顺序Lock —&gt; 同步代码块(已经进入方法体,分配了相对应资源) —&gt; 同步方法（在方法体之外） 线程的通信 涉及到的三个方法 wait(): 一旦执行此方法，当前线程就会进入阻塞状态，并释放同步监视器 notify(): 一旦执行方法，就会唤醒被 wait 的第一个线程，如果有多个线程被 wait，就唤醒优先级最高的那个 notifyAll(): 一旦执行此方法，就会唤醒所有被 wait()的线程 注意点： wait()，notify().notifyAll()：三个方法必须用在同步代码块或同步方法中。（lock也不可以用这三个） wait()，notify()，notifyAll(): 三个方法的调用者必须是同步代码块同步方法的同步监视器。否则会出现IllegalMonitorStateException异常 wait()，notify()，notifyAll()：三个方法时定义在java.lang.Object类中，不在Thread里。 释放锁： 会释放锁的操作： 当前线程的同步方法、同步代码执行结束。 当前线程在同步代码块、同步方法中遇到 break、return 终止该代码块、该方法的继承执行。 当前线程在同步代码块、同步方法中出现未处理的 Error 或 Exception，导致异常结束 当前线程在同步代码块、同步方法中执行了线程对象的 wait()方法，当前线程暂停，并释放锁 不会释放锁的操作： 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield(); 方法只是暂停当前线程的执行 线程执行同步代码块时，其他线程调用了线程的 supend()方法将线程挂起，该线程不会释放锁（同步监视器） 例子：使用两个线程打印 1-100。线程 1, 线程 2 交替打印 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Number implements Runnable&#123; private int number = 1; Object obj = new Object(); @Override public void run() &#123; while(true)&#123; synchronized(obj)&#123; //唤醒线程 obj.notify(); if(number &lt;= 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:&quot; +number); number++; try &#123; // 使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; sleep()和wait()的异同 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态 不同点： 两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait() 调用的要求不同：sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中 如果两个方法都使用在同步代码块或同步方法中,sleep()不会释放锁，wait()会 JDK5.0 新增线程创建方式（2种）新增方式一：实现Callable接口 与Runnable相比，Callable功能更强大些 call()相比run()方法，可以有返回值 方法可以抛出异常，被外面的操作捕获，获取异常信息 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 Future接口 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等 FutureTask是Future接口的唯一的实现类 FutureTask同时实现了Runnable，Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值 步骤 创建一个实现Callable的实现类 实现call方法，将此线程需要执行的操作声明在call()中 创建Callable接口实现类的对象 将此Callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask的对象 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread的对象，并调用start() 获取Callable中call方法的返回值 1234567891011121314151617181920212223242526class NumThread implements Callable&#123; int sum = 0; @Override public Object call() throws Exception&#123; System.out.println(&quot;aaa&quot;); &#125; return sum;//自动装箱 //如果没必要有返回值则返回null&#125;public class ThreadNew&#123; public static void main(Sting[] args)&#123; NumThread numThread = new NumThread(); FutureTask futureTask = new FutureTask(numThread); new Thread(futureTask).start(); try&#123; //get()返回值即为FutureTask构造器参数Callable实现类重新的call()的返回值 Object sum = new futureTask.get(); System.out.println(sum); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125;catch(ExcutionException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 新增方式二：使用线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度（减少了创建线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 …. 线程池相关API JDK5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService: 真正的线程池接口。常见子类（实现类）ThreadPoolExecutor void execute(Runnable command): 执行任务/命令，没有返回值，一般用来执行Runnable Future submit(Callable task): 执行任务，有返回值，一般用来执行Callable void shutdown(): 关闭连接池 Executors: 工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool(): 创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n): 创建一个可重用固定线程数的线程池（常用） Executors.newSingleThreadExecutor(): 创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n): 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行 123456789101112131415161718public class ThreadPool&#123; public static void main(String[] args)&#123; //1.提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); //设置线程池的属性 ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; service1.setCorePoolSize(15); //service1.setKeepAliveTime(); //2.执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumThread1()); service.execute(new NumThread2()); //service.submit(Callable callable); //3.关闭连接池 service.shutdown(); &#125;&#125;","categories":[],"tags":[]},{"title":"java集合框架","slug":"java集合框架","date":"2021-08-12T22:36:20.000Z","updated":"2021-08-30T21:32:59.708Z","comments":true,"path":"2021/08/12/java集合框架/","link":"","permalink":"http://example.com/2021/08/12/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"集合","text":"集合 集合 概念：对象的容器，定义了对对象常用的操作，类似数组功能，都是对多个数据进行存储操作的结构，简称Java容器 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储(数据库，.txt, .jpg) 集合和数组 数组长度固定，集合长度不固定 数组可以存储基本类型和引用类型且一旦定义好之后类型不可变，集合只能存储引用类型 数组中提供的方法非常有限，对于增删改等操作非常不便，同时效率不高 获取数组中实际元素的个数的需求，数组没有现成的属性或者方法可用 数组存储数据的特点：有序，可重复。对于无序、不可重复的需求，不能满足。 位置：java.util.* 一. Java集合框架概述Java 集合可分为Collection和Map两种体系 Collection接口：单列数据，用来存储一个一个的对象，定义了存取一组对象的方法的集合 List：元素有序、可重复的集合（有下标）”动态数组” 实现类：ArrayList, LinkedList, Vector Set：元素无序、不可重复的集合（无下标）”数学里的集合” 实现类：HashSet, LinkedHashSet, TreeSet Map接口：双列数据，用来存储一对一对的数据，保存具有映射关系“key-value对”的集合 “函数 y = f(x) x是key, y是value” 实现类：HashMap, LinkedHashMap, TreeMap, HashTable, Properties Collection接口继承树 Map接口继承树 二. Collection接口中的方法的使用2.1 add(c) size() addAll(c) clear() isAmpty()1234567891011121314151617181920212223242526public class CollectionTest&#123; public void Test1()&#123; Collection coll = new ArrayList();//多态 //add(Object e):将元素e添加到集合中 coll.add(&quot;AA&quot;); coll.add(123);//自动装箱 coll.add(new Date()); //size():获取元素的个数 System.out.println(coll.size());//3 //addAll(Collection c):将coll1集合中的元素添加到当前的集合中 Collection coll1 = new ArrayList(); coll1.add(456); coll1.add(&quot;asd&quot;); coll.addAll(coll1); System.out.println(coll.size());//5 //clear()：清空元素 coll.clear(); //isEmpty(): 判断当前集合是否为空 System.out.println(coll.isEmpty());//true &#125;&#125; 2.2 contains() containsAll(c) remove(o) removeAll(c) retainAll(c) equals(o) hashCode() toArray() iterator()向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals(). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class CollectinoTest &#123; public void test()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //1.contains(Object obj):判断当前集合中是否包含obj //我们在判断时会调用obj对象所在类的equals()。 //每判断集合中的一项就调用一次equals() boolean contains = coll.contains(123); System.out.println(contains);//true System.out.println(coll.contains(new String(&quot;Tom&quot;)));//true 因为String类中重写了equals()方法 System.out.println(coll.contains(new Person(&quot;Jerry&quot;,20)));//false --&gt;true（重写Person中的equals后） //2.containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。(子集) Collection coll1 = Arrays.asList(123,4567); System.out.println(coll.containsAll(coll1)); //3.remove(Object obj):从当前集合中移除obj元素。 coll.remove(1234); System.out.println(coll);//有则返回true成功删除，没有则返回false coll.remove(new Person(&quot;Jerry&quot;,20)); System.out.println(coll); //4. removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。 Collection coll1 = Arrays.asList(123,456); coll.removeAll(coll1); System.out.println(coll); //5.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合 Collection coll1 = Arrays.asList(123,456,789); coll.retainAll(coll1); System.out.println(coll); //6.equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。 Collection coll1 = new ArrayList(); coll1.add(456); coll1.add(123); coll1.add(new Person(&quot;Jerry&quot;,20)); coll1.add(new String(&quot;Tom&quot;)); coll1.add(false); System.out.println(coll.equals(coll1));//list有顺序，set无序 //7.hashCode():返回当前对象的哈希值 System.out.println(coll.hashCode()); //8.集合 ---&gt;数组：toArray() Object[] arr = coll.toArray(); for(int i = 0;i &lt; arr.length;i++)&#123; System.out.println(arr[i]); &#125; //拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList() List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;); System.out.println(list); List arr1 = Arrays.asList(123, 456); System.out.println(arr1);//[123, 456] List arr2 = Arrays.asList(new int[]&#123;123, 456&#125;); System.out.println(arr2.size());//1 会把一个数组看成一个整体 List arr3 = Arrays.asList(new Integer[]&#123;123, 456&#125;); System.out.println(arr3.size());//2 //9.iterator():返回Iterator接口的实例，用于遍历集合元素。放在迭代器细写 &#125;&#125; 三. 迭代器接口Iterator（只针对于Collection，不包括Map） Iterator对象称为迭代器(设计模式的一种)，主要用于遍历Collection 集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 Iterator 仅用于遍历集合，Iterator本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 3.1 next() hasNext()next(): 指针下移，将下移以后集合位置上的元素返回 hasNext(): 判断是否还有下一个元素（没有下移） 12345678910111213141516171819202122232425262728293031public class IteratorTest &#123; public void test()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); Iterator iterator = coll.iterator(); //方式一：没有这么写的，容易报错 System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next());//报异常：NoSuchElementException，因为只有5项 //方式二：不推荐 for(int i = 0;i &lt; coll.size();i++)&#123; System.out.println(iterator.next()); &#125; //方式三：推荐 while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; 两种常见错误写法12345678910//错误方式一：跳着输出，且最后报错Iterator iterator = coll.iterator();while(iterator.next() != null)&#123; System.out.println(iterator.next());&#125;//错误方式二：会死循环且一直输出第一项//集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。while(coll.iterator().hasNext())&#123; System.out.println(coll.iterator().next());&#125; 3.2 remove() 迭代器内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove() 如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException 1234567891011121314151617181920212223242526272829public class IteratorTest &#123; public void test3()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //删除集合中”Tom” Iterator iterator = coll.iterator(); while(iterator.hasNext())&#123;// iterator.remove();//报IllegalStateException Object obj = iterator.next(); if(&quot;Tom&quot;.equals(obj))&#123; iterator.remove();// iterator.remove();//报IllegalStateException &#125; &#125; //遍历集合 iterator = coll.iterator();//回到起点 while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; 3.3 补充：Enumeration(了解就行) Enumeration接口是Iterator迭代器的“古老版本” 123456Enumeration stringEnum = new StringTokenizer(&quot;a-b*c-d-e-g&quot;, &quot;-&quot;);while(stringEnum.hasMoreElements())&#123; Object obj= stringEnum.nextElement(); System.out.println(obj); &#125; 3.4 增强for循环（另一种迭代方式） Java 5.0 提供了foreach循环迭代访问Collection和数组。 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。 遍历集合的底层还是调用Iterator完成操作。 for(集合元素的类型 局部变量 : 集合对象) 123456789101112131415161718192021222324252627//对集合for(Object obj : coll)&#123; System.out.println(obj);&#125;//对数组int[] arr = new int[]&#123;1,2,3,4,5,6&#125;;for(int i : arr)&#123;//注意不是int[] System.out.println(i);&#125;//普通for循环和增强for循环的对比public void test3()&#123; String[] arr = new String[]&#123;&quot;MM&quot;,&quot;MM&quot;,&quot;MM&quot;&#125;; //方式一：普通for赋值 输出GG for(int i = 0;i &lt; arr.length;i++)&#123; arr[i] = &quot;GG&quot;; &#125; //方式二：增强for循环 输出MM for(String s : arr)&#123; s = &quot;GG&quot;; &#125; for(int i = 0;i &lt; arr.length;i++)&#123; System.out.println(arr[i]); &#125; &#125; 四. Collection子接口之一：List接口 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组（动态） List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。 List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。 JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 三者的异同 同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据 不同： ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储 LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 Vector：作为List接口的古老实现类，不常用；线程安全的，效率低；底层使用Object[] elementData存储 4.1 ArrayList源码分析4.1.1 jdk7的情况下 ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData list.add(123);//elementData[0] = new Integer(123); … list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。 结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity) 4.1.2 jdk8中ArrayList的变化 ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组 list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0] … 后续的添加和扩容操作与jdk 7 无异 4.1.3 小结 jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。 4.2 LinkedList的源码分析 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高 LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。 LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null list.add(123);//将123封装到Node中，创建了Node对象。 其中，Node定义为：体现了LinkedList的双向链表的说法 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; //next变量记录下一个元素的位置 this.prev = prev; //prev变量记录前一个元素的位置 &#125;&#125; 4.3 Vector源码分析 Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。 在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。 在扩容方面，默认扩容为原来的数组长度的2倍。jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。 4.4 List接口中的常用方法4.4.1 方法List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。 void add(intindex, Object ele):在index位置插入ele元素 boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 Object get(int index):获取指定index位置的元素 int indexOf(Object obj):返回obj在集合中首次出现的位置 int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置 Object remove(int index):移除指定index位置的元素，并返回此元素 Object set(int index, Object ele):设置指定index位置的元素为ele List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ListTest &#123; /* * 总结：常用方法 * 增：add(Object obj) * 删：remove(int index) / remove(Object obj) * 改：set(int index, Object ele) * 查：get(int index) * 插：add(int index, Object ele) * 长度：size() */ public void test()&#123; ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add(&quot;AA&quot;); list.add(new Person(&quot;Tom&quot;,12)); list.add(456);//可以有相同元素 //void add(int index, Object ele):在index位置插入ele元素 list.add(1,&quot;BB&quot;);//第一位是0 System.out.println(list); //boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 List list1 = Arrays.asList(1, 2, 3); list.addAll(list1);// list.add(list1);会把整体当成一个元素加入到list System.out.println(list.size());//9 //Object get(int index):获取指定index位置的元素 System.out.println(list.get(2)); &#125;&#125;public void tets2()&#123; ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add(&quot;AA&quot;); list.add(new Person(&quot;Tom&quot;,12)); list.add(456); //int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1. int index = list.indexOf(4567); System.out.println(index);//-1 //int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1. System.out.println(list.lastIndexOf(456));//4 //Object remove(int index):移除指定index位置的元素，并返回此元素 Object obj = list.remove(0); System.out.println(obj); System.out.println(list); //Object set(int index, Object ele):设置指定index位置的元素为ele list.set(1,&quot;CC&quot;); System.out.println(list); //List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合 List subList = list.subList(2, 4); System.out.println(subList); System.out.println(list);&#125; 4.4.2 遍历123456789101112131415161718192021222324252627282930313233/* * ① Iterator迭代器方式 * ② 增强for循环 * ③ 普通的循环 */public class ListTest &#123; public void test()&#123; ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add(&quot;AA&quot;); //方式一：Iterator迭代器方式 Iterator iterator = list.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; System.out.println(&quot;***************&quot;); //方式二：增强for循环 for(Object obj : list)&#123; System.out.println(obj); &#125; System.out.println(&quot;***************&quot;); //方式三：普通for循环 for(int i = 0;i &lt; list.size();i++)&#123; System.out.println(list.get(i)); &#125; &#125;&#125; 4.5 易错点区分List中remove(int index)和remove(Object obj) 123456789101112131415public class ListEver &#123; public void testListRemove() &#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list);//输出什么 &#125; private void updateList(List list) &#123; list.remove(2);//[1,2] list.remove(new Integer(2));//[1,3] &#125;&#125; 五. Collection子接口之二：Set接口Set接口的框架结构 Collection接口：单列集合，用来存储一个一个的对象 |——Set接口：存储无序的、不可重复的数据 —&gt;高中讲的“集合” |——HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值 |——LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历。对于频繁的遍历操作，LinkedHashSet效率高于HashSet. |——TreeSet：底层是红黑树。可以按照添加对象的指定属性，进行排序。 注意点 Set接口中没有定义额外的方法，使用的都是Collection中声明过的方法。 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。（遍历输出的顺序一直一样） 不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个 要求向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode() 和 equals() 要求：重写的hashCode()和equals()尽可能保持一致性（相等的对象必须具有相等的散列码） 重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。 5.1 HashSet添加元素的过程 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值 此哈希值接着通过某种算法（散列表）计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素： 情况1：如果此位置上没有其他元素，则元素a添加成功。 情况2：如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值： ​ 情况2.1：如果hash值不相同，则元素a添加成功。​ 情况2.2：如果hash值相同，进而需要调用元素a所在类的equals()方法：​ equals()返回true,元素a添加失败（里面已经有了相同的元素）​ equals()返回false,则元素a添加成功。 对于后两种添加成功的情况而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。jdk 7 :元素a放到数组中，指向原来的元素。jdk 8 :原来的元素在数组中，指向元素a总结：七上八下 HashSet底层：数组+链表的结构。 5.2 关于hashCode()和equals()的重写1. 重写hashCode() 方法的基本原则 在程序运行时，同一个对象多次调用hashCode()方法应该返回相同的值。 当两个对象的equals()方法比较返回true时，这两个对象的hashCode()方法的返回值也应相等。 对象中用作equals() 方法比较的Field，都应该用来计算hashCode值。 2. 重写equals() 方法的基本原则 当一个类有自己特有的“逻辑相等”概念, 当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。 因此，违反了“相等的对象必须具有相等的散列码”。 结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。 3.Eclipse/IDEA工具里hashCode()的重写 以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？ 选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突） 并且31只占用5bits,相乘造成数据溢出的概率较小。 31可以由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率） 31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突) 5.3 LinkedHashSet LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。 优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。 LinkedHashSet插入性能略低于HashSet，但在迭代访问Set 里的全部元素时有很好的性能。 LinkedHashSet不允许集合元素重复。 5.4 TreeSet 注意点 1.向TreeSet中添加的数据，要求是相同类的对象。(可排序) 2.两种排序方式：自然排序（实现Comparable接口重写compareTo()）和 定制排序（Comparator）。默认情况下，TreeSet采用自然排序。 3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals(). 4.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals(). TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。 TreeSet底层使用红黑树结构存储数据。特点：有序，查询速度比List快 六. Map接口 6.1 多个实现类的对比 Map:双列数据，存储key-value对的数据 —-类似于高中的函数：y = f(x) HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。 TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。底层使用红黑树 Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value Properties:常用来处理配置文件。key和value都是String类型 HashMap的底层：数组+链表 （jdk7及之前） 数组+链表+红黑树 （jdk 8） 面试题： 1.HashMap的底层实现原理？ 2.HashMap 和 Hashtable的异同？ 3.ConcurrentHashMap 与 Hashtable的异同？ 6.2 Map的key-value结构理解 key和value都可以是任何引用类型的数据 Map中的key：无序的、不可重复的，使用Set存储所有的key —-&gt; key所在的类要重写equals()和hashCode() （以HashMap为例） Map中的value：无序的、可重复的，使用Collection存储所有的value —-&gt;value所在的类要重写equals() 一个键值对：key-value构成了一个Entry对象。 Map中的entry：无序的、不可重复的，使用Set存储所有的entry 6.3 HashMap HashMap是Map接口使用频率最高的实现类。 允许使用null键和null值，与HashSet一样，不保证映射的顺序。 HashMap判断两个key相等的标准是：两个key通过equals()方法返回true，hashCode值也相等。 HashMap判断两个value相等的标准是：两个value通过equals()方法返回true。 6.3.1 HashMap的底层实现原理6.3.1.1 以jdk7为例说明12345678910HashMap map = new HashMap();//在实例化以后，底层创建了长度是16的一维数组Entry[] table。//...可能已经执行过多次put...map.put(key1,value1);/* *首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 *如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1 * 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。&lt;----情况2.如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：如果equals()返回false:此时key1-value1添加成功。&lt;----情况3.如果equals()返回true:使用value1替换value2。 * 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 *在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。 默认的扩容方式：扩容为原来容量的2倍，不是满了才扩，并将原有的数据复制过来。 */ 6.3.1.2 jdk8相较于jdk7在底层方面的不同 new HashMap():底层没有创建一个长度为16的数组 jdk 8底层的数组是：Node[],而非Entry[] 首次调用put()方法时，底层创建长度为16的数组 jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 4.2当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。（查找效率高） 6.3.2 HashMap源码中的重要常量 DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 MAXIMUM_CAPACITY：HashMap的最大支持容量， 2^30 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75 （如自己设不能小于0） TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8 UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64 （桶中的Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作，这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍） table：存储元素的数组，总是2的n次幂 entrySet：存储具体元素的集 size：HashMap中存储的键值对的数量 modCount：HashMap扩容和结构改变的次数 threshold：扩容的临界值，=容量填充因子：16 0.75 =&gt; 12 loadFactor：填充因子 越大，数组的利用率越高，但是链表越长 越小，链表越短，但是利用率低 6.4 LinkedHashMap LinkedHashMap是HashMap的子类 在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序 与LinkedHashSet类似，LinkedHashMap可以维护Map的迭代顺序，顺序与key-value对的插入顺序一致 主要变化在于LinkedHashMap的Entry内部类，对应HashMap的Node内部类 1234567891011121314//Hashmap中的内部类：Nodestatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;&#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;&#125;//LinkedHashMap中的内部类：Entrystatic class Entry&lt;K,V&gt; extands HashMap.Node&lt;K,V&gt;&#123; Entry&lt;K,V&gt; before, after;//能够记录添加元素的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next)&#123; super(hash, key, value, next); &#125;&#125; 6.5 Map中的常用方法添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 12345678910111213141516171819202122232425262728293031323334353637383940public void test5()&#123; Map map = new HashMap(); map.put(&quot;AA&quot;,123); map.put(45,1234); map.put(&quot;BB&quot;,56); //遍历所有的key集：keySet() Set set = map.keySet(); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; //遍历所有的values集：values() Collection values = map.values(); for(Object obj : values)&#123; System.out.println(obj); &#125; //遍历所有的key-values //方式一： Set entrySet = map.entrySet(); Iterator iterator1 = entrySet.iterator(); while (iterator1.hasNext())&#123; Object obj = iterator1.next(); //entrySet集合中的元素都是entry Map.Entry entry = (Map.Entry) obj; System.out.println(entry.getKey() + &quot;----&gt;&quot; + entry.getValue()); &#125; //方式二： Set keySet = map.keySet(); Iterator iterator2 = keySet.iterator(); while(iterator2.hasNext())&#123; Object key = iterator2.next(); Object value = map.get(key); System.out.println(key + &quot;=====&quot; + value); &#125;&#125; 总结： 添加：put(Object key,Object value) 删除：remove(Object key) 修改：put(Object key,Object value) 查询：get(Object key) 长度：size() 遍历：keySet() / values() / entrySet() 6.6 TreeMap TreeMap存储Key-Value 对时，要求key必须是由同一个类创建的对象，因为需要根据key进行排序。TreeMap可以保证所有的Key-Value 对处于有序状态。 TreeSet底层使用红黑树结构存储数据 TreeMap的Key的排序： 自然排序：TreeMap的所有的Key 必须实现Comparable接口，而且所有的Key应该是同一个类的对象，否则将会抛出ClasssCastException 定制排序：创建TreeMap时，传入一个Comparator 对象，该对象负责对TreeMap中的所有key 进行排序。此时不需要Map 的Key实现Comparable 接口 TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。 6.7 Hashtable 小细节：t不大写，应该是hashtable是一个词 Hashtable是个古老的Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。 与HashMap不同，Hashtable不允许使用null 作为key和value 与HashMap一样，Hashtable也不能保证其中Key-Value 对的顺序 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 6.8 Properties处理属性文件 Properties 类是Hashtable的子类，该对象用于处理属性文件 由于属性文件里的key、value都是字符串类型，所以Properties 里的key和value都是字符串类型 存取数据时，建议使用setProperty(String key,Stringvalue)方法和getProperty(String key)方法 1234567891011121314151617181920212223242526public class PropertiesTest &#123; //Properties:常用来处理配置文件。key和value都是String类型 public static void main(String[] args)&#123; //try-catch-finally快捷键：Ctrl+Alt+T FileInputStream fis = null; try &#123; Properties pros = new Properties(); fis = new FileInputStream(&quot;jdbc.properties&quot;); pros.load(fis); //加载流对应文件 String name = pros.getProperty(&quot;name&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;name = &quot; + name + &quot;,password = &quot; + password); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 七. Collections工具类 可以类比操作数组的工具类：Arrays Collections 是一个操作Set、List和Map 等集合的工具类（不止操作Collection） Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法 排序操作：（均为static方法） reverse(List)：反转List 中元素的顺序 shuffle(List)：对List集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定List 集合元素按升序排序 sort(List，Comparator)：根据指定的Comparator 产生的顺序对List 集合元素进行排序 swap(List，int，int)：将指定list 集合中的i处元素和j 处元素进行交换 查找、替换操作：（均为static方法） Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 123456789101112List list = new ArrayList();list.add(123);list.add(43);list.add(765);//报异常：IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;) //List dest = new ArrayList();//因为dest的长度是0//Collections.copy(dest,list);//正确的：List dest = Arrays.asList(new Object[list.size()]);//[null,null,null]System.out.println(dest.size());//list.size();Collections.copy(dest,list);System.out.println(dest); - boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值 Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题 12//返回的list1即为线程安全的ListList list1 = Collections.synchronizedList(list); Collection 和 Collections的区别？ Collection是集合类的上级接口，继承于他的接口主要有Set 和List Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作","categories":[],"tags":[]},{"title":"常用类","slug":"java常用类","date":"2021-08-09T15:02:11.000Z","updated":"2021-08-12T15:35:51.667Z","comments":true,"path":"2021/08/09/java常用类/","link":"","permalink":"http://example.com/2021/08/09/java%E5%B8%B8%E7%94%A8%E7%B1%BB/","excerpt":"Object类 包装类 String类 BigDecimal Date Calendar SimpleDateFormat System类","text":"Object类 包装类 String类 BigDecimal Date Calendar SimpleDateFormat System类 Object类 java.lang.Object 超类，基类，所有类的直接或间接父类，位于继承树的最顶层 任何类如果没有extends，都默认直接继承Object类 Object类中定义的方法，是所有对象都具备的方法 Object类型可以存储任何对象 作为参数，可接受任何对象 作为返回值，可返回任何对象 getClass()12345678910public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;aaaa&quot;); Student s2 = new Student(&quot;bbbb&quot;); //判断s1和s2是不是同一个类型 Class class1 = s1.getClass(); Class class2 = s2.getClass(); class1 == class2 //true &#125;&#125; public final Class get Class(){} //Class是一种返回值类型 返回引用中存储的实际对象类型 应用：通常用于判断两个引用中实际存储对象类型是否一致 在反射中会用到 hashcode() public int hashCode(){} 返回该对象的哈希码值 哈希值是根据对象的地址或字符串或数字使用hash算法计算出来的int类型的数值 一般情况下相同对象返回相同哈希码，也就是说可以通过这个方法来判断两个对象是不是相同 12345678910111213public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;aaaa&quot;); Student s2 = new Student(&quot;bbbb&quot;); //hashcode int hash1 = s1.hashCode(); int hash2 = s2.hashCode(); hash1 == hash2; //false Student s3 = s1; hash1 == hash3; //True &#125;&#125; toString() public String toString(){} 返回该对象的字符串表示 12345678public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;aaaa&quot;); Student s2 = new Student(&quot;bbbb&quot;); //toString方法 System.out.println(s1.toString());//输出package.TestStudent@s1的哈希值 &#125;&#125; 可以根据程序需求覆盖（重写）该方法，如：展现对象的各个属性值 123456public class Student&#123; //重写toString public String toString()&#123; return &quot;Student [name=&quot; + name + &quot;]&quot;; &#125;&#125; Integer.toString()有一个重载方法 .toString(i, radix) radix代表进制 比如Integer.toString(15, 16)是f equals() public boolean equals(Object obj){} 默认实现为（this==obj），比较两个对象的地址是否相同 123456789101112public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;aaaa&quot;); Student s2 = new Student(&quot;bbbb&quot;); //equals方法：判断两个对象是否相等 s1.equals(s2);//false Student s4 = new Student(&quot;a&quot;); Student s5 = new Student(&quot;a&quot;); s4.equals(s5);//false 比较的是地址 &#125;&#125; 可进行重写，比较两个对象的内容是否相同，步骤： 比较两个引用是否指向同一个对象 判断obj是否为null 判断两个引用指向的实际对象类型是否一致 强制类型转换 依次比较各个属性值是否相同 1234567891011121314151617181920public class Student&#123; //重写equals public boolean equals(Object obj)&#123; //1比较两个引用是否指向同一个对象 if(this == obj)&#123; return true;&#125; //2判断obj是否为null if(obj == null)&#123; return false;&#125; //3判断两个引用指向的实际对象类型是否一致 //if(this.getClass()==obj.getClass())&#123;&#125;比较笨重的方法，也可行 if(obj instanceof Student)&#123;//instanceof判断对象是否是某种类型 //4强制类型转换 Student s = (Student)obj; //5比较属性 if(this.name.equals(s.getName())&amp;&amp;this.age.equals(s.getAge()))&#123; return true; &#125; &#125; return false; &#125;&#125; finalize() 当对象被判定为垃圾对象时，由JVM此方法，用来标记垃圾对象，进入回收队列 垃圾对象：没有有效引用指向此对象时，为垃圾对象 垃圾回收：由GC销毁垃圾对象，释放存储空间 自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象 手动回收机制：使用System.gc() 通知JVM执行垃圾回收 一般不用程序员自己调用 包装类 都在java.lang中 基本数据类型所对应的引用数据类型 Object可统一所有数据，包装类的默认值是null 基本数据类型（栈） 包装类型（堆） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 类型转换与装箱、拆箱需保证类型兼容，否则抛出NumberFormatException异常 装箱：栈到堆 拆箱：堆到栈 123456789101112131415161718192021public class Demo&#123; public static void main(String[] args)&#123; //JDK1.5之前 //类型转换：装箱，基本类型转成引用类型的过程 int num1 = 18;//基本类型 //使用Integer类创建对象 Integer integer1 = new Integer(num1); Integer integer2 = Integer.valueOf(num1); //类型转换：拆箱，引用类型转成基本类型的过程 Integer integer3 = new Integer(100);//引用类型 int num2 = integer3.intValue(); //在JDK1.5之后，Java提供自动装箱和拆箱 int age = 30; //自动装箱:自动会调用Integer.valueOf Integer integer4 = age; //自动拆箱 int age2 = integer4; &#125;&#125; parseXXX()静态方法 12345678910111213141516171819202122public class Demo&#123; public static void main(String[] args)&#123; //基本类型和字符串之间转换 //1 基本类型转成字符串 int n1 = 100; //1.1 使用+号 String s1 = n1 + &quot;&quot;; //1.2 使用Integer中的toString() String s2 = Integer.toString(s1); //字符串转成基本类型 String str = &quot;150&quot;; //使用Integer.parseXXX() int n2 = Integer.parseInt(str); //boolean类型字符串形式转成基本类型，&quot;true&quot; ----&gt; true 非&quot;true&quot;---&gt;false String str2 = &quot;true&quot;; boolean b1 = Boolean.parseBoolean(str2);//true String str3 = &quot;sdasd&quot;; boolean b2 = Boolean.parseBoolean(str3);//false &#125;&#125; valueOf()静态方法 整数缓冲区 Java预先创建了256个常用的整数包装类型对象 (-128到127) 在实际应用中，对已创建的对象进行复用 12345678910111213141516public class Demo&#123; public static void main(String[] args)&#123; //面试题 Integer integer1 = new Integer(100); Integer integer2 = new Integer(100); System.out.println(integer1 == integer2);//true Integer integer3 = Integer.valueOf(100); Integer integer4 = Integer.valueOf(100); System.out.println(integer3 == integer4);//true Integer integer5 = Integer.valueOf(200); Integer integer6 = Integer.valueOf(200); System.out.println(integer5 == integer6);//false &#125;&#125; String类 字符串是常量，创建之后不可改变 字符串字面值存储在字符串池（在方法区）中，可以共享 1234567public class Demo&#123; public static void main(String[] args)&#123; String name = &quot;hello&quot;; //&quot;hello&quot; 常量存储在字符串池中 name = &quot;zhangsan&quot;; String name2 = &quot;zhangsan&quot;; &#125;&#125; String s = “Hello” 产生一个对象，字符串池中存储 String s = new String(“Hello”) 产生两个对象，堆、池各存储一个 但实际运行的时候堆中的内容是指向方法区的存储地址 12345678public class Demo&#123; public static void main(String[] args)&#123; String str = new String(&quot;java&quot;); String str2 = new String(&quot;java&quot;); System.out.println(str == str2);//false System.out.println(str.equals(str2));//true 这里的equals在String里重写了 &#125;&#125; 常用方法 public int length(): 返回字符串的长度（汉字和空格也是1位） public char charAt(int index): 根据下标获取字符 public boolean contains(String str): 判断当前字符串中是否包含str public char[] toCharArray(): 将字符串转换成数组 public int indexOf(String str): 查找str首次出现的下标，存在则返回该下标（第一个字符），不存在则返回-1 public int lastIndexOf(String str): 查找字符串在当前字符串中最后一次出现的下标索引 public String trim(): 去掉字符串前后的空格 public String toUpperCase(): 将小写转成大写 public boolean endWith(String str): 判断字符串是否以str结尾 public String replace(char oldChar, char newChar): 将旧字符串替换成新字符串 public String[] split(String str): 根据str做拆分 compareTo()：比较大小，比较字典表里的顺序(第一位字符相减的得数，相同就比第二位) equals() 可变字符串 StringBuffer: 可变长字符串，JDK1.0提供，运行效率慢、线程安全 StringBuilder：可变长字符串，JDK5.0提供，运行效率快、线程不安全 和String区别： 效率比String高 比String节省内存 12345678910111213141516171819public class Demo&#123; public static void main(String[] args)&#123; StringBuffer sb = new StringBuffer(); //StringBuild sb = new StringBuild();也可以，下面的方法一样 //1 append()追加 sb.append(&quot;a&quot;);//a sb.append(&quot;b&quot;);//ab sb.append(&quot;c&quot;);//abc //2 insert() 添加 sb.insert(&quot;0,z&quot;);//zabc //3 replace() 替换 sb.replace(0,2,&quot;sss&quot;);//sssbc 左闭右开 //4delete() 删除 sb.delete(0,2);//sbc 左闭右开 sb.delete(0,sb.length());//清空 //输出用toString System.out.println(sb.toString()); &#125;&#125; BigDecimal123456789public class TestBigDecimal&#123; public static void main(String[] args)&#123; double d1 = 1.0; double d2 = 0.9; System.out.println(d1-d2);//会输出0.09999999999 double result = (1.4-0.5)/0.9; System.out.println(d1-d2);//会输出0.9999999999 &#125;&#125; 因为double是近似值存储，需要精确运算则需要借助BigDecimal 位置：java.math包中 作用：精确计算浮点数 创建方式：BigDecimal bd = new BigDecimal(“1.0”); 12345678public class TestBigDecimal&#123; public static void main(String[] args)&#123; BigDecimal bd1 = new BigDecimal(&quot;1.0&quot;); BigDecimal bd2 = new BigDecimal(&quot;0.9&quot;); BigDecimal r1 = bd1.subtract(bd2);//r1=0.1 //加法是.add() 减法是.subtract() 乘法是. multiply() 除法.divide()但是除不尽的时候要写保留几位小数或者声明四舍五入，否则会报错 &#125;&#125; 时间类型Date Date表示特定的瞬间，精确到毫秒。JKD1.1后，Date类中的大部分方法都已经被Calendar类中的方法所取代（因为在设计的时候不是很完美） 时间单位 1秒=1000毫秒 1毫秒=1000微秒 1微秒=1000纳秒 Calendar Calendar提供了获取或设置各种日历字段的方法 构造方法 protected Calendar():由于修饰符是protected 所以无法直接创建该对象 其他方法 12345678910111213141516171819202122232425262728public class Demo&#123; public static void main(String[] args)&#123; //1创建Calendar对象 Calendar calendar = Calendar.getInstance(); //输出 System.out.println(calendar.getTime().toLocaleString()); System.out.println(calendar.getTimeInMillis()); //2获取时间信息 //获取年 int year = calendar.get(Calendar.YEAR);//在Calendar源码中定义了常量YEAR=1 //月 0-11 int month = calendar.get(Calendar.MONTH); //日 int day = calendar.get(Calendar.DAY_OF_MONTH); //小时 int hour = calendar.get(Calendar.HOUR_OF_DAY);//24小时 int hour = calendar.get(Calendar.HOUR);//12小时 //分钟 int minute = calendar.get(Calendar.MINUTE); //秒 int second = calendar.get(Calendar.SECOND); //修改时间 Calendar calendar2 = Calendar.getInstance(); calendar2.set(Calendar.DAY_OF_MONTH, 5); calendar2.add(Calendar.HOUR, 1);//加一小时 减一小时可以-1 &#125;&#125; SimpleDateFormat SimpleDateFormat是一个以与语言环境有关的方法来格式化和解析日期的具体类 进行格式化（日期 —&gt; 文本）、解析（文本 —&gt; 日期） 常用的时间模式字母 12345678910111213public class Demo&#123; public static void main(String[] args)&#123; //1创建SimpleDateFormat对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); //2创建Date Date date = new Date(); //格式化date String str = sdf.format(date); System.out.println(str); //解析 Date date2 = sdf.parse(&quot;2021年02月12日 12-23-45&quot;) &#125;&#125; Syetem类 System系统类，主要用于获取系统的属性数据和其他操作，构造方法私有，方法都是静态的，因此使用的时候不用创建对象 123456789101112131415161718public class Demo&#123; public static void main(String[] args)&#123; //arraycopy 数组的复制 //是native方法，底层的c++，运行速度快 //Arrays.copyOf(original, newLength)的源码里是调用的System.arrayCopy /* 参数 src 源数组 srcPos 从哪个位置开始复制 dest 目标数组 destPos 目标数组的开始放的位置 length 复制的长度 */ int[] arr = &#123;2, 4, 3, 3, 21&#125;; int[] dest = new int[8]; System.arraycopy(arr,0,dest,0,arr.length); &#125;&#125;","categories":[],"tags":[]},{"title":"异常机制","slug":"异常机制","date":"2021-08-09T00:45:25.000Z","updated":"2021-08-08T19:14:49.791Z","comments":true,"path":"2021/08/09/异常机制/","link":"","permalink":"http://example.com/2021/08/09/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/","excerpt":"简单分类 异常体系结构 Error Exception 异常处理机制 自定义异常 实际经验","text":"简单分类 异常体系结构 Error Exception 异常处理机制 自定义异常 实际经验 异常异常指程序运行中出现的不期而至的各种情况，如：文件找不到、网络连接失败、非法参数等。 异常发生在程序运行期间，它影响了正常的程序执行流程。 简单分类 检查性异常（测试岗的人的主要工作） 是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在的文件时，一个异常就发生了，这些异常在编译时不能被简单的忽略 运行时异常 可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略 错误（ERROR） 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如当栈溢出时，一个错误就发生了，它们在编译也检查不到 异常体系结构Java把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中已经定义了许多的异常类，这些异常类分为两大类，错误Error（无法预见）和异常Exception（可以预见） AWTEError有关于GUI ErrorError对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关 这些异常发生时，Java虚拟机（JVM）一般会选择终止线程。 Exception在Exception分支中有一个重要的子类RunTimeException（运行时异常） ArrayIndexOutOfBoundsException（数组下标越界） NullPointerException（空指针异常） ArithmeticException（算数异常） MissingResourceException（丢失资源） ClassNotFoundException（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理也可以不处理 这些异常一般有程序逻辑错误引起，应该尽可能避免 和Error的区别：Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，JVM一般会选择终止线程。Exception通常是可以被程序处理的，并且在程序中应尽可能的去处理这些异常 异常处理机制 抛出异常 捕获异常 异常处理的五个关键字：try catch finally throw throws try-catch-finally快捷键：选中代码Ctrl+Alt+t 12345678910111213141516171819public class Test&#123; public static void main(String[] args)&#123; int a = 1; int b = 0; try&#123;//try监控区域 System.out.println(a/b); &#125;catch(ArithmeticException e)&#123;//想要捕获的异常类型 //语句 可以打印错误信息，也可以System.exit()退出程序 &#125;catch(Exception e )&#123; //可以有多个catch &#125;catch(Throwable t)&#123; //把范围大的写在后面，因为一旦有catch执行就直接跳过其他的catch进入finally &#125;finally&#123; //处理善后工作，无论catch执没执行，finally一定执行 //可以不要finally //一般用来关闭资源 &#125; &#125;&#125; throw throws123456789101112public class Test&#123; public static void main(String[] args)&#123; &#125; public void test(int a, int b) throws ArithmeticException&#123;//假设在方法中，不能用throw处理异常，在方法上用throws抛出异常 if (b==0)&#123; throw new ArithmeticException();//主动抛出的异常，throw一般在方法中用 &#125; a/b &#125;&#125; 自定义异常使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。 步骤： 创建自定义异常类 在方法中通过throw抛出异常对象 如果在当前抛出异常的方法中处理异常，可以用try-catch语句并处理；否则在方法的声明处通过throws指明要抛出给方法调用者的异常，继续进行下一步操作 在出现异常方法的调用者中捕获并处理异常 1234567891011121314151617181920212223242526272829public class MyException extends Exception()&#123; //传递数字&gt;10 private int detail; public MyException(int a)&#123;//构造器 this.detail = a; &#125; //异常的打印信息 @Override public String toString()&#123; return &quot;MyException&#123;&quot; + detail + &quot;&#125;&quot;; &#125;&#125;public class Test&#123; //可能会存在异常的方法 加static是为了不用建对象 static void test(int a) throws My Exception&#123; if(a&gt;10)&#123; throw new MyException(a);//抛出 &#125; &#125; public static void main(String[] args)&#123; try&#123; test(11); &#125;catch(MyException e)&#123; System.out.println(&quot;MyException:&quot; + e); &#125; &#125;&#125;//结果会输出MyException:MyException&#123;11&#125; 实际经验 常用类（object类—hashcode() toString() clone() getClass() notify() wait() equals() Math类 Random类 File类(增删改查文件) 包装类（自动拆箱和装箱） Data类(Date SimpleDateFormat Calendar) String类(操作量较少) StringBuffer(可变长 append() 多线程数据量大 效率低安全) Stringbuilder(可变长 单线程数据量较大 效率高不安全)） io 集合","categories":[],"tags":[]},{"title":"数据结构","slug":"数据结构","date":"2021-08-08T00:26:51.000Z","updated":"2021-08-07T19:27:09.502Z","comments":true,"path":"2021/08/08/数据结构/","link":"","permalink":"http://example.com/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"初步","text":"初步 数据结构的存储方式数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储） 队列和栈既可以用数组（要处理扩容缩容的问题），也可以用链表（需要更多的内存空间存储节点指针）实现 图的两种表示方法：邻接表（比较省空间，效率不如邻接矩阵）是链表，邻接矩阵（判断连通性迅速，可以进行矩阵运算去解决问题，但是如果图比较稀疏的话会很耗空间）是二维数组。 散列表是通过散列函数把键映射到一个大数组里。对于解决散列冲突的方法，拉链法需要链表特性，操作简单但需要额外的空间存储指针。线性探查法需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。 树：用数组实现就是堆，因为堆是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单。用链表实现常见的树，在链表树的基础上又衍生出了二叉搜索树，AVL树，红黑树，区间树，B树等等 Redis数据库提供列表、字符串、集合等等几种常用数据结构，但是底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。 二者的优缺点： 数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 数据结构的基本操作对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。 而所有操作可以分成线性（for/while）和非线性（递归）两种。 数组的遍历框架（线性迭代结构） 12345void traverse(int[] array)&#123; for(int i=0; i &lt; array.length; i++)&#123; //迭代访问array[i] &#125;&#125; 链表的遍历框架（线性和非线性都可以） 123456789101112131415//基本的单链表节点class ListNode&#123; int val; ListNode next;&#125;//线性迭代void traverse(Listnode head)&#123; for(ListNode p = head; p != null; p = p.next)&#123; &#125;&#125;//递归void traverse(Listnode head)&#123; traverse(head.next);&#125; 二叉树的遍历框架（非线性递归结构） 12345678910//基本的二叉树节点class TreeNode&#123; int val; TreeNode left, right;&#125;void traverse(TreeNode root)&#123; traverse(root.left); traverse(root.right);&#125; 扩展为N叉树的遍历框架 1234567891011//基本的N叉树节点class TreeNode&#123; int val; TreeNode[] children;&#125;void traverse(TreeNode root)&#123; for(TreeNode child; root.children)&#123; traverse(child); &#125; &#125; 二叉树的遍历1234567void traverse(TreeNode root) &#123; // 前序遍历 traverse(root.left) // 中序遍历 traverse(root.right) // 后序遍历&#125; 刷题顺序相关先单链表，再二叉树，栈和队列","categories":[],"tags":[]},{"title":"面向对象","slug":"面向对象","date":"2021-08-07T19:21:17.000Z","updated":"2021-08-08T17:44:13.879Z","comments":true,"path":"2021/08/07/面向对象/","link":"","permalink":"http://example.com/2021/08/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"创建和初始化对象 封装 重载 继承 重写 多态 Instanceof 类型转换 Static 代码块 抽象类 接口 内部类","text":"创建和初始化对象 封装 重载 继承 重写 多态 Instanceof 类型转换 Static 代码块 抽象类 接口 内部类 面向对象 面向对象的本质：以类的方式组织代码，以对象的组织（封装）数据 抽象 三大特性 封装 继承 多态 创建和初始化对象使用new关键字创建对象 使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。 类中的构造器也称为构造方法，是在创建对象时必须要调用的。并且构造器有以下两个特点 必须与类的名字相同 必须没有返回类型，也不能写void 构造器的核心作用 使用new关键字，本质是在调用构造器 用来初始化对象的值 要注意，一旦定义了有参构造器，无参构造器就必须显示定义（程序不会再自动生成） tip: 在ideaj中alt+enter 生成构造器 封装程序设计要追求 高内聚，低耦合 属性私有，get/set 1234567891011121314151617181920212223public class student&#123; private String name; private int id; private char sex; public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getId()&#123; return this.id; &#125; public void setId(int id)&#123; this.id = id; &#125; public char getSex()&#123; return this.sex; &#125; public char setSex(char sex)&#123; this.sex = sex; &#125;&#125; 在ideaj里按alt+insert加get、set方法 封装的意义 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 系统可维护增加了 重载在一个类中，有相同的类型，但是有不同的参数类型 仅仅方法的返回值类型不同不可以是重载 继承继承的本质是对一批类的抽象 Java中类只有单继承，没有单继承（extends后面只能跟一个） 继承是类和类之间的一种关系，除此之外的关系还有依赖、组合、聚合等 继承关系的两个类，一个为子类（派生类），一个为父类（基类） 子类和父类之间具有 ‘is a’ 的关系 子类无法继承父类中private的属性和方法 可以 父类 a = new 子类(); 即父类的引用可以指向子类 object类 在Java中，所有的类，都默认直接或者间接继承Object super 用super调用父类的构造方法，super必须在子类构造器的第一行 super只能出现在子类的方法或者构造器中 super和this不能同时调用构造方法（因为都要在第一行） VS this： 代表的对象不同： this：本身调用者这个对象 super：只能在继承条件才可以使用 前提 this：没有继承也可以使用 super：只能在继承条件才可以使用 构造方法 this：本类的构造 super：父类的构造 方法重写重写都是方法的重写，和属性无关 前提：需要有继承关系，子类重写父类的方法 注意点 方法名必须相同 参数列表必须相同 修饰符：范围可以扩大，但不能缩小，public &gt; protected &gt; default &gt; private 抛出的异常：范围可以被缩小，但不能扩大 ClassNotFoundException —&gt; Exception(大) 重写子类和父类必须要一致，方法体不同 为什么需要重写： 父类的功能，子类不一定需要，或者不一定满足 Alt+Insert:Override 多态 即同一方法可以根据发送对象的不同而采取多种不同的行为方式 一个对象的实际类型是确定的，但是可以指向对象的引用的类型有很多（父类，父类的父类或有关系的类） 多态注意事项： 多态是方法的多态，属性没有多态 父类和子类要有联系（有类型转换异常 ClassCastException） 存在条件：继承关系，方法需要重写，父类引用指向子类对象 Father f1 = new Son(); 不能被重写的： static 方法，属于类，它不属于实例 final 常量 private方法 12345678910111213141516171819202122232425262728293031323334353637383940//父类public class Person&#123; public void run()&#123; System.out.println(&quot;run&quot;); &#125;&#125;//子类public class Student extends Person&#123; @Override public void run()&#123; System.out.println(&quot;son&quot;); &#125; public void eat()&#123; System.out.println(&quot;eat&quot;); &#125;&#125;//测试类public class Application&#123; public static void main(String[] args)&#123; /*一个对象的实际类型是确定的，即new后面的是确定的， 比如 new Student() new Person() 但是前面可以指向的引用类型就不确定了：父类的引用指向子类 比如Person a = new Student() */ //Student能调用的方法都是自己的或者是继承父类的 Student s1 = new Student(); //Person父类可以指向子类，但是不能调用子类独有的方法 Person s2 = new Student(); Object s3 = new Student(); //能调用什么方法主要看前面的引用，和右边关系不大 s1.eat();//输出eat ((Student) s2).eat();//向下强制转换，输出eat s1.run();//输出son s2.run();//输出son &#125;&#125; InstanceofX instanceof Y 如果X和Y有父子关系，编译就通过，如果没有编译就报错 123456789101112131415161718192021222324252627282930313233//父类public class Person&#123;&#125;//子类public class Student extends Person&#123;&#125;//子类public class teacher extends Person&#123; &#125;//测试类public class Application&#123; public static void main(String[] args)&#123; Object object = new Student(); //object &gt; String //object &gt; Person &gt; Teacher //object &gt; Person &gt; Student System.out.println(object instanceof Student);//true System.out.println(object instanceof Person);//true System.out.println(object instanceof Object);//true System.out.println(object instanceof Teacher);//false System.out.println(object instanceof String);//false Person person = new Student(); System.out.println(person instanceof String);//完全没有关系的两项，编译会报错 Student student = new Student(); System.out.println(object instanceof Teacher);//编译会报错 System.out.println(object instanceof String);//编译会报错 &#125;&#125; 类型转换父类辈分比子类高 子类可以自动转换为父类，但是可能会丢失一些自己本来的方法 父类转成子类需要强制转换 可以理解成，比如父类是人，子类是学生，子类的学生可以自动说成人，但是会丢失自己的特点，但是人不一定都是学生，需要强制转换 Static和类一起最先加载，可以直接通过类调用 123456789101112131415161718public class Student&#123; private static int age;//静态属性 private double score; public void run()&#123; &#125; public static void go()&#123; //静态方法 &#125; public static void main(String[] args)&#123; new Student().score; new Student().age; new Student().run(); Student.age;//静态属性可以直接用类调用 Student.go()//静态方法可以直接用类调用 &#125;&#125; 代码块123456789101112public class Person&#123; &#123; //代码块（匿名代码块） //对象建立的时候被调用，在构造器之前调用 //可以用来初始化 &#125; static&#123; //静态代码块 //在类加载的时候执行，永久只执行一次 &#125;&#125; 抽象类123456//关键字abstract 需要子类去extendspublic abstract class Action&#123; //abstract 抽象方法，只有方法名字，没有方法的实现 public abstract void doSth(); &#125; 不能new这个抽象类，只能靠子类来，只能靠子类去实现他它 抽象类中可以写普通的方法 抽象方法必须在抽象类中 抽象类有构造器 抽象类的所有方法，继承它的子类，都必须要重写它的方法，除非子类也是抽象类 接口（interface）普通类：只有具体实现 抽象类：具体实现和规范（抽象方法）都有 接口：只有规范，自己无法写方法 （比抽象类还要抽象，约束和实现分离：面向接口编程） 1234567891011121314151617181920212223242526272829303132333435//接口 关键字interface 接口都需要实现类public interface UserService&#123; //常量 （public static final) //但是一般不会再接口类设置常量 int AGE=99; //接口中的所有定义的方法都是抽象的 (public abstract) void add(String name); void delete(String name); void update(String name); void query(String name);&#125;//实现类用implements//实现了接口的类，必须重写接口中的方法//可以实现两个接口，将两个接口的方法全部重写public class UserServiceImpl implements UserService&#123; @Override public void add(String name)&#123; &#125; @Override public void delete(String name)&#123; &#125; @Override public void update(String name)&#123; &#125; @Override public void query(String name)&#123; &#125;&#125; 接口的作用： 约束 定义一些方法，让不同的人实现 public abstract public static final 接口不能被实例化，接口中没有构造方法 implements可以实现多个接口 必须要重写接口中的方法 内部类内部类就是在一个类的内部再定义一个类，比如A类中定义了一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类 成员内部类 12345678910111213141516171819202122232425public class outer&#123; private int id=10; public void out()&#123; System.out.println(&quot;out&quot;); &#125; class Inner&#123; public void in()&#123; System.out.println(&quot;in&quot;); &#125; //获得外部类的私有属性 public void getID()&#123; System.out.println(id); &#125; &#125;&#125;public class Application&#123; public static void main(String[] args)&#123; Outer outer = new Outer(); //通过外部类来实例化内部类 Outer.Inner inner = outer.new Inner(); inner.in();//输出in inner.getId();//输出10 &#125;&#125; 静态内部类（内部类是public static class Inner{}） 局部内部类(内部类在外部类的方法里) 1234567public class Outer&#123; public void method&#123; class Inner&#123; &#125; &#125;&#125; 匿名内部类 1234567891011121314151617181920212223public class Test&#123; public static void main(String[] args)&#123; //没有名字初始化类，不用将实例保存到变量中 new Apple().eat(); new UserService()&#123;//不重写方法会报错 @Override public void hello()&#123; &#125;; &#125; &#125;&#125;public class Apple&#123; public void eat&#123; &#125;&#125;public interface UserService&#123; void hello();&#125;","categories":[],"tags":[]},{"title":"数组","slug":"数组","date":"2021-08-06T16:14:04.000Z","updated":"2021-08-06T17:33:32.414Z","comments":true,"path":"2021/08/06/数组/","link":"","permalink":"http://example.com/2021/08/06/%E6%95%B0%E7%BB%84/","excerpt":"数组的定义，声明，创建 内存分析 数组的三种初始化四个基本特点，使用 多维数组 Arrays类 冒泡排序 稀疏数组","text":"数组的定义，声明，创建 内存分析 数组的三种初始化四个基本特点，使用 多维数组 Arrays类 冒泡排序 稀疏数组 数组的定义数组是相同类型数据的有序集合 其中每一个数据称作一个数组元素，通过下标访问 数组的声明和创建123456789//声明数组int[] a;//首选int a[];//c和c++风格//创建数组int[] nums = new int[10];//赋值 没有赋值则自动取默认值int[0] = 0;//获取数组长度arrays.length; 内存分析 堆 存放new的对象和数组 可以被所有的线程共享，不会存放别的对象引用 栈 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里的具体地址） 方法区 可以被所有的线程共享 包含了所有的class和static变量 数组的三种初始化 数组的四个基本特点 长度是确定的，一旦被创建，大小不可以再改变 其元素必须是相同类型，不能混合 元素可以是基本类型也可以是引用类型 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组本身是在堆中 数组的使用 For-Each循环 123for(i=0;i&lt;arrays.length;i++)&#123; &#125; 数组作方法入参 123for(int array :arrays)&#123; //增强for循环，JDK1.5开始可以， 这样取不到下标 &#125; 数组作返回值 多维数组可以看做是数组的数组，比如二维数组 12345int[][] a = new int[3][2];int[][] a = &#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;4,5&#125;&#125;;//获取长度a.length;//3a[0].length;//2 Arrays类数组的工具类java.util.Arrays 里面的方法都是用static修饰的静态方法 冒泡排序总共有八大算法 冒泡排序有两层循环，外层冒泡轮数，里层依次比较 时间复杂度为O(n2) 代码 12345678910111213public int[] sort(int[] array)&#123; int temp = 0; for(int i=0; i &lt; array.length-1; i++)&#123; for(int j = 0; j &lt; array.length-1-i; j++)&#123; if(array[j] &gt; array[j+1])&#123; temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; return array;&#125; 稀疏数组是一种数据结构（一共三列） 当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方式是： 记录数组一共有几行几列，有多少个不同值 把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模。下图左边是原始数组，右边是稀疏数组。 第一行保存数组的行数，列数，有效值的个数 其他行保存有效值的行，列，本身的值","categories":[],"tags":[]},{"title":"java方法","slug":"java方法","date":"2021-08-05T21:16:55.000Z","updated":"2021-08-06T09:13:32.647Z","comments":true,"path":"2021/08/05/java方法/","link":"","permalink":"http://example.com/2021/08/05/java%E6%96%B9%E6%B3%95/","excerpt":"定义 调用 重载 命令行传参 可变参数 递归","text":"定义 调用 重载 命令行传参 可变参数 递归 原子性：一个方法最好只完成一个功能，方便维护 方法的定义类似于其他语言的函数 方法包含一个方法头和一个方法体 1234修饰符 返回值类型 方法名(参数类型 参数名)&#123; //方法体 return 返回值;&#125; 形式参数：在方法被调用时用于接收外界输入的数据 实际参数：调用方法时实际传给方法的数据 方法的调用调用方法：对象名.方法名（实参列表） 值传递(java)和引用传递 方法的重载在一个类中，有相同的类型，但是有不同的参数类型 仅仅方法的返回值类型不同不可以是重载 命令行传参1234567public class CommandLine&#123; public static void main(String[] args)&#123; for(int i=0; i&lt;args.length;i++)&#123; System.out.println(args[i]); &#125; &#125;&#125; 可变参数（不定项参数）JDK1.5开始，Java支持传递同类型的可变参数给一个方法 在指定参数类型后加一个省略号，三个点(…) 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明 123public void test(int... num)&#123; //相当于是传递了num[]数组进来&#125; 递归递归头：什么时候不调用自身方法，如果没有头，将陷入死循环 递归体：什么时候调用自身方法 很占资源，容易卡死","categories":[],"tags":[]},{"title":"java流程控制","slug":"java流程控制","date":"2021-08-05T20:53:59.000Z","updated":"2021-08-18T19:17:49.827Z","comments":true,"path":"2021/08/05/java流程控制/","link":"","permalink":"http://example.com/2021/08/05/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"Scanner对象 顺序结构 选择结构 循环结构","text":"Scanner对象 顺序结构 选择结构 循环结构 Scanner对象java.util.Scanner Java5的新特性，可以通过Scanner类来获取用户的输入 基本语法 1Scanner s = new Scanner(System.in); 通过next()和nextLine()获取字符串 通过hasNext()和hasNextLine()判断有没有输入 属于io流如果不关闭会一直占用资源，记得scanner.close() next() 一定要读取到有效字符后才可以结束输入 对输入有效字符之前遇到的空白，next()方法会自动将其去掉 输入有效字符后，将输入的空白作为分隔符或结束符 next()不能得到带有空格的字符串 nextLine() 以Enter为结束符 可以获得空白 顺序结构最基本的默认结构，从上到下执行 选择结构 if单选择结构 123if()&#123; &#125; if双选择结构 12345if()&#123; &#125;else&#123; &#125; if多选择结构 123456789if()&#123; &#125;else if()&#123; &#125;else if()&#123; &#125;else&#123; &#125; switch多选择结构 12345678910switch()&#123; case value1: //语句 break; case value2: //语句 break; default: //语句&#125; switch语句中的变量类型可以是byte, short, int, char, String(从Java SE 7开始支持) case标签必须为字符串常量或者字面量 case没有break把后面的所有语句全执行 循环结构 while循环 1234567while()&#123; &#125;while(true)&#123;//死循环 //服务器监听响应&#125; do..while循环 123do&#123; &#125;while()//循环体至少会执行一次 for循环 1234for(初始化;布尔表达式;更新)&#123; //初始化语句可以是空语句，也可以是一种类型多个变量 //布尔表达式和更新也可以是空语句，即for(;;)&#123;&#125;是死循环&#125; 增强for循环 Java5引入的一种主要用于数组或者集合的增强型for循环 12345for(声明语句:表达式)&#123; //声明语句：声明新的局部变量，变量的类型必须和数组元素的类型匹配。作用域限定值循环语句块，其值与此时数组元素的值相等 //表达式：是要访问的数组名，或者是返回值为数组的方法&#125;//更详细的在java集合里面写 break和continue break：退出整个循环 continue：退出本轮循环","categories":[],"tags":[]},{"title":"java基础语法","slug":"java基础语法","date":"2021-08-02T21:22:04.000Z","updated":"2021-08-05T16:46:37.573Z","comments":true,"path":"2021/08/02/java基础语法/","link":"","permalink":"http://example.com/2021/08/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"注释 标识符 数据类型 类型转换 变量 常量 变量命名规范 运算法 包机制 JavaDoc","text":"注释 标识符 数据类型 类型转换 变量 常量 变量命名规范 运算法 包机制 JavaDoc 注释单行注释 1//单行注释 多行注释 12345/*多行注释多行注释多行注释*/ 文档注释（JavaDoc） 1234/** *@Description HelloWorld *@Author RW */ 标识符类名，方法名，变量名都是标识符 所有标识符必须以A-Z, a-z, $, _开始 首字符之后的可以是A-Z, a-z, $, _，数字 不能用关键字 标识符大小写敏感 可以用中文，但是不建议 关键字 String不是关键字，是类 数据类型java，c++是强类型语言（所有变量必须先定义后使用） 安全性高，速度慢 js是弱类型语言 java的数据类型分为两大类 基本类型 整数类型：byte占1字节, short占2字节, int占4字节, long占8字节 long类型要在数字后面加L， long num = 30L; 浮点类型：float占4字节, double占8字节 float类型要在数字后面加F， float num = 30F; 字符类型：char占2字节 boolean类型：占1位 值只有true和false 引用类型 类 接口 数组 java中表示进制 二进制 0b 八进制 0 十六进制 0x 浮点数（float double）是离散的，有舍入误差，接近但不等于 123float f = 0.1f;//0.1double d = 1.0/10;//0,1System.out.println(f==d); //会输出false 123float d1 = 2313131323123113f;float d2 = d1 + 1;System.out.println(d1==d2); //会输出true 因此，最好避免使用浮点数进行比较 所有的字符本质还是数字 编码 Unicode 2字节 0-65536 1char c = &#x27;\\u0061&#x27;; //c输出‘a&#x27; 转义字符 \\t 制表符 \\n 换行 ……. 类型转换低———————————————————————————————-&gt;高 byte,short,char —&gt; int —&gt; long —&gt; float —&gt; double 从低到高，占的位越来越多，且小数高于整数 强制转换 高-低 (类型)变量名 e.g. int(100) 自动转换 低-高 注意点： 不能对布尔值进行转换 不能把对象类型转换为不相干类型 再把高容量转换到低容量时，要做强制转换 转换的时候可能存在内存溢出或者精度的问题 在操作比较大的数的时候，要注意溢出 tips：JDK7新特性，大的数可以在中间加下划线方便看 比如1_0000_0000 变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域 变量作用域 类变量 实例变量：从属于对象（类）可以不初始化值，有自动初始化 数值类型初始化默认0 0.0 布尔值默认是false 除了基本变量，其余的默认值都为null(比如string) 局部变量：必须声明和初始化值 不会自动初始化 1234567public class demo&#123; static double salary = 2500;//类变量 String str = &#x27;abc&#x27;;//实例变量 public static void main(String[] args)&#123; int a = 0;//局部变量 &#125;&#125; 常量初始化后不能再改值 1static final double PI = 3.14;//常量名一般使用大写字符 tip：public，final和static都是修饰符，不存在先后顺序 变量命名规范类成员变量，局部变量：首字母小写，驼峰 常量：大写字母和下划线 MAX_VALUE 类名：首字母大写，驼峰 方法名：首字母小写，驼峰 run() 运算符算数运算符：+ - * / % ++ — (++a是先自增在赋值，a++是先赋值再自增) 赋值运算符：= 关系运算符：&gt;, &lt;, &gt;=, &lt;=, ==, !=, instanceof 逻辑运算符（与或非）：&amp;&amp; || ! 短路运算：a&amp;&amp;b 如果a已经是假的，那么不在看b 位运算符： &amp; | ^ ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; 2*8=16 可以是2&lt;&lt;3 = 16 条件运算符： ? : 扩展赋值运算符： +=, -=, *=, /= 12345678910long a = 23123123;int b= 123;short c = 10;byte d = 8;/*a+b+c+d结果是Long类型b+c+d结果是int类型c+d结果是int类型因为有long就是long，没有long就是int*/ 包机制本质就是文件夹 格式是package com.baidu.baike; 且必须在前上面 一般利用公司域名倒置作为包名 JavaDoc用来生成自己API文档 参数信息 @author作者名 @version版本号 @since指明需要最早使用的jdk版本 @param参数名 @return返回值情况 @throws异常抛出情况 生成步骤（也可以用idea之类的打开） ​ 找到java文件所在文件夹，打开cmd ​ 输入javadoc -encoding UTF-8 -charset UTF-8 Doc.java ​ 然后在文件夹中就可以找到","categories":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/categories/java-SE/"}],"tags":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/tags/java-SE/"}]},{"title":"win10下基于hexo+github搭建个人博客过程","slug":"win10下基于hexo-github搭建个人博客过程","date":"2021-08-02T19:50:31.000Z","updated":"2021-08-02T14:10:54.605Z","comments":true,"path":"2021/08/02/win10下基于hexo-github搭建个人博客过程/","link":"","permalink":"http://example.com/2021/08/02/win10%E4%B8%8B%E5%9F%BA%E4%BA%8Ehexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/","excerpt":"这个博客就是基于hexo+github所搭建的网站，在此先记录一下搭建的过程","text":"这个博客就是基于hexo+github所搭建的网站，在此先记录一下搭建的过程 Step1 安装nodejs在https://nodejs.org/上下载14.17.4LTS（我搭建时的最新版本） 下载完后直接无脑下一步安装就好。（亲测没必要装在c盘） 安装完之后，win+R调出搜索，输入cmd，打开命令行，分别输入1node -v 1npm -v 查看是否成功安装。 Step2 安装cnpm在命令行中输入 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完之后输入1cnpm -v 查看是否成功安装 Step3 用cnpm安装hexo框架在命令行中输入 1cnpm install -g hexo-cli 安装完之后输入 1hexo -v 查看是否成功安装 Step4 在任意位置建立空文件夹这个文件夹用于存放博客的所有内容。e.g.我的路径是E:\\study\\blog\\ Step5 进入刚刚创建的文件夹在空白处按住shift单击右键打开PowerShell窗口。在命令行中输入 1hexo init 这里注意由于我的路径是在E盘中，所以并没有管理员权限的问题，如果在c盘可能会有（我没自己试过） 初始化后进入文件夹会发现出现很多文件。 Step6 启动hexo还是在blog文件夹下打开PowerShell窗口。在命令行中输入 1hexo s 会出现提示http://localhost:4000/，在浏览器输入这个网址进入博客。Ctrl+c退出 Step7 创建文章还是在blog文件夹下打开PowerShell窗口。在命令行中输入 1hexo n &#x27;文章名字&#x27; 之后进入/source/posts，发现新出现了一个 文章名字.md 的文件。直接txt格式打开用markdown格式写文章就行。 Step8 上传文章返回blog文件夹下打开PowerShell窗口。在命令行中输入 123hexo cleanhexo ghexo s 再从http://localhost:4000/进入博客，发现文章已经上传。 Step9 将博客部署到githubhttps://github.com/登陆自己的github账号，点右上角的+，New repository 在Repository name输入 自己的github名.github.io 比如我的github叫enheng244，我就是enheng244.github.io 然后Create repository 在blog文件夹下打开PowerShell窗口。在命令行中输入 1cnpm install --save hexo-deployer-git 安装完之后，在blog文件下找到_config.yml，进入后在最底部找到#Deployment，配置如下 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/enheng244/enheng244.github.io.git branch: master repo行换成自己的github地址即可。 Step10 进入博客此时在浏览器输入enheng244.github.io即可访问自己的博客 Step11 换主题在github上或其他地方可以找到很多主题，可以按照其中的文档去换主题 Step12 常用命令1234hexo cleanhexo ghexo s hexo d","categories":[],"tags":[]},{"title":"markdown语法总结","slug":"markdown语法总结","date":"2021-08-02T17:35:12.000Z","updated":"2021-08-05T13:55:53.823Z","comments":true,"path":"2021/08/02/markdown语法总结/","link":"","permalink":"http://example.com/2021/08/02/markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"从前只是零零散散的用过一些markdown形式，既然下定决心要开始写博客了，所有最先做的先要把markdown的语法先过一遍，以后就不用再每次用的时候去一直百度。","text":"从前只是零零散散的用过一些markdown形式，既然下定决心要开始写博客了，所有最先做的先要把markdown的语法先过一遍，以后就不用再每次用的时候去一直百度。 标题 一级标题（一个# + 空格 + 标题名）二级标题（二个# + 空格 + 标题名）三级标题（三个# + 空格 + 标题名）四级标题（四个# + 空格 + 标题名）五级标题（五个# + 空格 + 标题名）最多支持到六级标题（六个# + 空格 + 标题名）字体Hello.World!(粗体前后各加两个星号) Hello.World!（斜体前后各加一个星号） Hello.World!（粗体加粗体前后各加三个星号） Hello.World!（前后各加两个波浪号） 引用 前面&gt;加空格 分割线三个减号—- 三个星号* 图片感叹号中括号小括号前面写图片名后面写路径 可以是本地的也可是网上的路径 超链接点击跳转到百度 中括号小括号前面写文字后面写网址 列表有序列表： 1.空格 a b c 无序列表： -空格 a b c 表格名字|性别|生日 —|—|—| 张三|男|1997.1.1 名字 性别 生日 张三 男 1997.1.1 代码三个` （tab上面的）+ 语言，比如java + 回车 1import","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-08-01T16:52:41.360Z","updated":"2021-08-02T12:45:19.379Z","comments":true,"path":"2021/08/01/hello-world/","link":"","permalink":"http://example.com/2021/08/01/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/categories/java-SE/"}],"tags":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/tags/java-SE/"}]}