{"meta":{"title":"BinSpace","subtitle":"subtitle待填充","description":"早日发财！","author":"Bin","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2021-08-05T16:37:42.000Z","updated":"2021-08-05T16:39:56.400Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-08-05T16:42:14.000Z","updated":"2021-08-05T16:46:17.616Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"异常机制","slug":"异常机制","date":"2021-08-08T17:45:25.000Z","updated":"2021-08-08T19:14:49.791Z","comments":true,"path":"2021/08/09/异常机制/","link":"","permalink":"http://example.com/2021/08/09/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/","excerpt":"简单分类 异常体系结构 Error Exception 异常处理机制 自定义异常 实际经验","text":"简单分类 异常体系结构 Error Exception 异常处理机制 自定义异常 实际经验 异常异常指程序运行中出现的不期而至的各种情况，如：文件找不到、网络连接失败、非法参数等。 异常发生在程序运行期间，它影响了正常的程序执行流程。 简单分类 检查性异常（测试岗的人的主要工作） 是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在的文件时，一个异常就发生了，这些异常在编译时不能被简单的忽略 运行时异常 可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略 错误（ERROR） 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如当栈溢出时，一个错误就发生了，它们在编译也检查不到 异常体系结构Java把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中已经定义了许多的异常类，这些异常类分为两大类，错误Error（无法预见）和异常Exception（可以预见） AWTEError有关于GUI ErrorError对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关 这些异常发生时，Java虚拟机（JVM）一般会选择终止线程。 Exception在Exception分支中有一个重要的子类RunTimeException（运行时异常） ArrayIndexOutOfBoundsException（数组下标越界） NullPointerException（空指针异常） ArithmeticException（算数异常） MissingResourceException（丢失资源） ClassNotFoundException（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理也可以不处理 这些异常一般有程序逻辑错误引起，应该尽可能避免 和Error的区别：Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，JVM一般会选择终止线程。Exception通常是可以被程序处理的，并且在程序中应尽可能的去处理这些异常 异常处理机制 抛出异常 捕获异常 异常处理的五个关键字：try catch finally throw throws try-catch-finally快捷键：选中代码Ctrl+Alt+t 12345678910111213141516171819public class Test&#123; public static void main(String[] args)&#123; int a = 1; int b = 0; try&#123;//try监控区域 System.out.println(a/b); &#125;catch(ArithmeticException e)&#123;//想要捕获的异常类型 //语句 可以打印错误信息，也可以System.exit()退出程序 &#125;catch(Exception e )&#123; //可以有多个catch &#125;catch(Throwable t)&#123; //把范围大的写在后面，因为一旦有catch执行就直接跳过其他的catch进入finally &#125;finally&#123; //处理善后工作，无论catch执没执行，finally一定执行 //可以不要finally //一般用来关闭资源 &#125; &#125;&#125; throw throws123456789101112public class Test&#123; public static void main(String[] args)&#123; &#125; public void test(int a, int b) throws ArithmeticException&#123;//假设在方法中，不能用throw处理异常，在方法上用throws抛出异常 if (b==0)&#123; throw new ArithmeticException();//主动抛出的异常，throw一般在方法中用 &#125; a/b &#125;&#125; 自定义异常使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。 步骤： 创建自定义异常类 在方法中通过throw抛出异常对象 如果在当前抛出异常的方法中处理异常，可以用try-catch语句并处理；否则在方法的声明处通过throws指明要抛出给方法调用者的异常，继续进行下一步操作 在出现异常方法的调用者中捕获并处理异常 1234567891011121314151617181920212223242526272829public class MyException extends Exception()&#123; //传递数字&gt;10 private int detail; public MyException(int a)&#123;//构造器 this.detail = a; &#125; //异常的打印信息 @Override public String toString()&#123; return &quot;MyException&#123;&quot; + detail + &quot;&#125;&quot;; &#125;&#125;public class Test&#123; //可能会存在异常的方法 加static是为了不用建对象 static void test(int a) throws My Exception&#123; if(a&gt;10)&#123; throw new MyException(a);//抛出 &#125; &#125; public static void main(String[] args)&#123; try&#123; test(11); &#125;catch(MyException e)&#123; System.out.println(&quot;MyException:&quot; + e); &#125; &#125;&#125;//结果会输出MyException:MyException&#123;11&#125; 实际经验 常用类（object类–hashcode() toString() clone() getClass() notify() wait() equals() Math类 Random类 File类(增删改查文件) 包装类（自动拆箱和装箱） Data类(Date SimpleDateFormat Calendar) String类(操作量较少) StringBuffer(可变长 append() 多线程数据量大 效率低安全) Stringbuilder(可变长 单线程数据量较大 效率高不安全)） io 集合","categories":[],"tags":[]},{"title":"数据结构","slug":"数据结构","date":"2021-08-07T17:26:51.000Z","updated":"2021-08-07T19:27:09.502Z","comments":true,"path":"2021/08/08/数据结构/","link":"","permalink":"http://example.com/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"初步","text":"初步 数据结构的存储方式数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储） 队列和栈既可以用数组（要处理扩容缩容的问题），也可以用链表（需要更多的内存空间存储节点指针）实现 图的两种表示方法：邻接表（比较省空间，效率不如邻接矩阵）是链表，邻接矩阵（判断连通性迅速，可以进行矩阵运算去解决问题，但是如果图比较稀疏的话会很耗空间）是二维数组。 散列表是通过散列函数把键映射到一个大数组里。对于解决散列冲突的方法，拉链法需要链表特性，操作简单但需要额外的空间存储指针。线性探查法需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。 树：用数组实现就是堆，因为堆是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单。用链表实现常见的树，在链表树的基础上又衍生出了二叉搜索树，AVL树，红黑树，区间树，B树等等 Redis数据库提供列表、字符串、集合等等几种常用数据结构，但是底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。 二者的优缺点： 数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组**如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)**。 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 数据结构的基本操作对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。 而所有操作可以分成线性（for/while）和非线性（递归）两种。 数组的遍历框架（线性迭代结构） 12345void traverse(int[] array)&#123; for(int i=0; i &lt; array.length; i++)&#123; //迭代访问array[i] &#125;&#125; 链表的遍历框架（线性和非线性都可以） 123456789101112131415//基本的单链表节点class ListNode&#123; int val; ListNode next;&#125;//线性迭代void traverse(Listnode head)&#123; for(ListNode p = head; p != null; p = p.next)&#123; &#125;&#125;//递归void traverse(Listnode head)&#123; traverse(head.next);&#125; 二叉树的遍历框架（非线性递归结构） 12345678910//基本的二叉树节点class TreeNode&#123; int val; TreeNode left, right;&#125;void traverse(TreeNode root)&#123; traverse(root.left); traverse(root.right);&#125; 扩展为N叉树的遍历框架 1234567891011//基本的N叉树节点class TreeNode&#123; int val; TreeNode[] children;&#125;void traverse(TreeNode root)&#123; for(TreeNode child; root.children)&#123; traverse(child); &#125; &#125; 二叉树的遍历1234567void traverse(TreeNode root) &#123; // 前序遍历 traverse(root.left) // 中序遍历 traverse(root.right) // 后序遍历&#125; 刷题顺序相关先单链表，再二叉树，栈和队列","categories":[],"tags":[]},{"title":"面向对象","slug":"面向对象","date":"2021-08-07T12:21:17.000Z","updated":"2021-08-08T17:44:13.879Z","comments":true,"path":"2021/08/07/面向对象/","link":"","permalink":"http://example.com/2021/08/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"创建和初始化对象 封装 重载 继承 重写 多态 Instanceof 类型转换 Static 代码块 抽象类 接口 内部类","text":"创建和初始化对象 封装 重载 继承 重写 多态 Instanceof 类型转换 Static 代码块 抽象类 接口 内部类 面向对象 面向对象的本质：以类的方式组织代码，以对象的组织（封装）数据 抽象 三大特性 封装 继承 多态 创建和初始化对象使用new关键字创建对象 使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。 类中的构造器也称为构造方法，是在创建对象时必须要调用的。并且构造器有以下两个特点 必须与类的名字相同 必须没有返回类型，也不能写void 构造器的核心作用 使用new关键字，本质是在调用构造器 用来初始化对象的值 要注意，一旦定义了有参构造器，无参构造器就必须显示定义（程序不会再自动生成） tip: 在ideaj中alt+enter 生成构造器 封装程序设计要追求 高内聚，低耦合 属性私有，get/set 1234567891011121314151617181920212223public class student&#123; private String name; private int id; private char sex; public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getId()&#123; return this.id; &#125; public void setId(int id)&#123; this.id = id; &#125; public char getSex()&#123; return this.sex; &#125; public char setSex(char sex)&#123; this.sex = sex; &#125;&#125; 在ideaj里按alt+insert加get、set方法 封装的意义 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 系统可维护增加了 重载在一个类中，有相同的类型，但是有不同的参数类型 仅仅方法的返回值类型不同不可以是重载 继承继承的本质是对一批类的抽象 Java中类只有单继承，没有单继承（extends后面只能跟一个） 继承是类和类之间的一种关系，除此之外的关系还有依赖、组合、聚合等 继承关系的两个类，一个为子类（派生类），一个为父类（基类） 子类和父类之间具有 ‘is a’ 的关系 子类无法继承父类中private的属性和方法 可以 父类 a = new 子类(); 即父类的引用可以指向子类 object类 在Java中，所有的类，都默认直接或者间接继承Object super 用super调用父类的构造方法，super必须在子类构造器的第一行 super只能出现在子类的方法或者构造器中 super和this不能同时调用构造方法（因为都要在第一行） VS this： 代表的对象不同： this：本身调用者这个对象 super：只能在继承条件才可以使用 前提 this：没有继承也可以使用 super：只能在继承条件才可以使用 构造方法 this：本类的构造 super：父类的构造 方法重写重写都是方法的重写，和属性无关 前提：需要有继承关系，子类重写父类的方法 注意点 方法名必须相同 参数列表必须相同 修饰符：范围可以扩大，但不能缩小，public &gt; protected &gt; default &gt; private 抛出的异常：范围可以被缩小，但不能扩大 ClassNotFoundException –&gt; Exception(大) 重写子类和父类必须要一致，方法体不同 为什么需要重写： 父类的功能，子类不一定需要，或者不一定满足 Alt+Insert:Override 多态 即同一方法可以根据发送对象的不同而采取多种不同的行为方式 一个对象的实际类型是确定的，但是可以指向对象的引用的类型有很多（父类，父类的父类或有关系的类） 多态注意事项： 多态是方法的多态，属性没有多态 父类和子类要有联系（有类型转换异常 ClassCastException） 存在条件：继承关系，方法需要重写，父类引用指向子类对象 Father f1 = new Son(); 不能被重写的： static 方法，属于类，它不属于实例 final 常量 private方法 12345678910111213141516171819202122232425262728293031323334353637383940//父类public class Person&#123; public void run()&#123; System.out.println(&quot;run&quot;); &#125;&#125;//子类public class Student extends Person&#123; @Override public void run()&#123; System.out.println(&quot;son&quot;); &#125; public void eat()&#123; System.out.println(&quot;eat&quot;); &#125;&#125;//测试类public class Application&#123; public static void main(String[] args)&#123; /*一个对象的实际类型是确定的，即new后面的是确定的， 比如 new Student() new Person() 但是前面可以指向的引用类型就不确定了：父类的引用指向子类 比如Person a = new Student() */ //Student能调用的方法都是自己的或者是继承父类的 Student s1 = new Student(); //Person父类可以指向子类，但是不能调用子类独有的方法 Person s2 = new Student(); Object s3 = new Student(); //能调用什么方法主要看前面的引用，和右边关系不大 s1.eat();//输出eat ((Student) s2).eat();//向下强制转换，输出eat s1.run();//输出son s2.run();//输出son &#125;&#125; InstanceofX instanceof Y 如果X和Y有父子关系，编译就通过，如果没有编译就报错 123456789101112131415161718192021222324252627282930313233//父类public class Person&#123;&#125;//子类public class Student extends Person&#123;&#125;//子类public class teacher extends Person&#123; &#125;//测试类public class Application&#123; public static void main(String[] args)&#123; Object object = new Student(); //object &gt; String //object &gt; Person &gt; Teacher //object &gt; Person &gt; Student System.out.println(object instanceof Student);//true System.out.println(object instanceof Person);//true System.out.println(object instanceof Object);//true System.out.println(object instanceof Teacher);//false System.out.println(object instanceof String);//false Person person = new Student(); System.out.println(person instanceof String);//完全没有关系的两项，编译会报错 Student student = new Student(); System.out.println(object instanceof Teacher);//编译会报错 System.out.println(object instanceof String);//编译会报错 &#125;&#125; 类型转换父类辈分比子类高 子类可以自动转换为父类，但是可能会丢失一些自己本来的方法 父类转成子类需要强制转换 可以理解成，比如父类是人，子类是学生，子类的学生可以自动说成人，但是会丢失自己的特点，但是人不一定都是学生，需要强制转换 Static和类一起最先加载，可以直接通过类调用 123456789101112131415161718public class Student&#123; private static int age;//静态属性 private double score; public void run()&#123; &#125; public static void go()&#123; //静态方法 &#125; public static void main(String[] args)&#123; new Student().score; new Student().age; new Student().run(); Student.age;//静态属性可以直接用类调用 Student.go()//静态方法可以直接用类调用 &#125;&#125; 代码块123456789101112public class Person&#123; &#123; //代码块（匿名代码块） //对象建立的时候被调用，在构造器之前调用 //可以用来初始化 &#125; static&#123; //静态代码块 //在类加载的时候执行，永久只执行一次 &#125;&#125; 抽象类123456//关键字abstract 需要子类去extendspublic abstract class Action&#123; //abstract 抽象方法，只有方法名字，没有方法的实现 public abstract void doSth(); &#125; 不能new这个抽象类，只能靠子类来，只能靠子类去实现他它 抽象类中可以写普通的方法 抽象方法必须在抽象类中 抽象类有构造器 抽象类的所有方法，继承它的子类，都必须要重写它的方法，除非子类也是抽象类 接口（interface）普通类：只有具体实现 抽象类：具体实现和规范（抽象方法）都有 接口：只有规范，自己无法写方法 （比抽象类还要抽象，约束和实现分离：面向接口编程） 1234567891011121314151617181920212223242526272829303132333435//接口 关键字interface 接口都需要实现类public interface UserService&#123; //常量 （public static final) //但是一般不会再接口类设置常量 int AGE=99; //接口中的所有定义的方法都是抽象的 (public abstract) void add(String name); void delete(String name); void update(String name); void query(String name);&#125;//实现类用implements//实现了接口的类，必须重写接口中的方法//可以实现两个接口，将两个接口的方法全部重写public class UserServiceImpl implements UserService&#123; @Override public void add(String name)&#123; &#125; @Override public void delete(String name)&#123; &#125; @Override public void update(String name)&#123; &#125; @Override public void query(String name)&#123; &#125;&#125; 接口的作用： 约束 定义一些方法，让不同的人实现 public abstract public static final 接口不能被实例化，接口中没有构造方法 implements可以实现多个接口 必须要重写接口中的方法 内部类内部类就是在一个类的内部再定义一个类，比如A类中定义了一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类 成员内部类 12345678910111213141516171819202122232425public class outer&#123; private int id=10; public void out()&#123; System.out.println(&quot;out&quot;); &#125; class Inner&#123; public void in()&#123; System.out.println(&quot;in&quot;); &#125; //获得外部类的私有属性 public void getID()&#123; System.out.println(id); &#125; &#125;&#125;public class Application&#123; public static void main(String[] args)&#123; Outer outer = new Outer(); //通过外部类来实例化内部类 Outer.Inner inner = outer.new Inner(); inner.in();//输出in inner.getId();//输出10 &#125;&#125; 静态内部类（内部类是public static class Inner{}） 局部内部类(内部类在外部类的方法里) 1234567public class Outer&#123; public void method&#123; class Inner&#123; &#125; &#125;&#125; 匿名内部类 1234567891011121314151617181920212223public class Test&#123; public static void main(String[] args)&#123; //没有名字初始化类，不用将实例保存到变量中 new Apple().eat(); new UserService()&#123;//不重写方法会报错 @Override public void hello()&#123; &#125;; &#125; &#125;&#125;public class Apple&#123; public void eat&#123; &#125;&#125;public interface UserService&#123; void hello();&#125;","categories":[],"tags":[]},{"title":"数组","slug":"数组","date":"2021-08-06T09:14:04.000Z","updated":"2021-08-06T17:33:32.414Z","comments":true,"path":"2021/08/06/数组/","link":"","permalink":"http://example.com/2021/08/06/%E6%95%B0%E7%BB%84/","excerpt":"数组的定义，声明，创建 内存分析 数组的三种初始化四个基本特点，使用 多维数组 Arrays类 冒泡排序 稀疏数组","text":"数组的定义，声明，创建 内存分析 数组的三种初始化四个基本特点，使用 多维数组 Arrays类 冒泡排序 稀疏数组 数组的定义数组是相同类型数据的有序集合 其中每一个数据称作一个数组元素，通过下标访问 数组的声明和创建123456789//声明数组int[] a;//首选int a[];//c和c++风格//创建数组int[] nums = new int[10];//赋值 没有赋值则自动取默认值int[0] = 0;//获取数组长度arrays.length; 内存分析 堆 存放new的对象和数组 可以被所有的线程共享，不会存放别的对象引用 栈 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里的具体地址） 方法区 可以被所有的线程共享 包含了所有的class和static变量 数组的三种初始化 数组的四个基本特点 长度是确定的，一旦被创建，大小不可以再改变 其元素必须是相同类型，不能混合 元素可以是基本类型也可以是引用类型 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组本身是在堆中 数组的使用 For-Each循环 123for(i=0;i&lt;arrays.length;i++)&#123; &#125; 数组作方法入参 123for(int array :arrays)&#123; //增强for循环，JDK1.5开始可以， 这样取不到下标 &#125; 数组作返回值 多维数组可以看做是数组的数组，比如二维数组 12345int[][] a = new int[3][2];int[][] a = &#123;&#123;1,2&#125;,&#123;2,3&#125;,&#123;4,5&#125;&#125;;//获取长度a.length;//3a[0].length;//2 Arrays类数组的工具类java.util.Arrays 里面的方法都是用static修饰的静态方法 冒泡排序总共有八大算法 冒泡排序有两层循环，外层冒泡轮数，里层依次比较 时间复杂度为O(n2) 代码 12345678910111213public int[] sort(int[] array)&#123; int temp = 0; for(int i=0; i &lt; array.length-1; i++)&#123; for(int j = 0; j &lt; array.length-1-i; j++)&#123; if(array[j] &gt; array[j+1])&#123; temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; return array;&#125; 稀疏数组是一种数据结构（一共三列） 当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方式是： 记录数组一共有几行几列，有多少个不同值 把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模。下图左边是原始数组，右边是稀疏数组。 第一行保存数组的行数，列数，有效值的个数 其他行保存有效值的行，列，本身的值","categories":[],"tags":[]},{"title":"java方法","slug":"java方法","date":"2021-08-05T14:16:55.000Z","updated":"2021-08-06T09:13:32.647Z","comments":true,"path":"2021/08/05/java方法/","link":"","permalink":"http://example.com/2021/08/05/java%E6%96%B9%E6%B3%95/","excerpt":"定义 调用 重载 命令行传参 可变参数 递归","text":"定义 调用 重载 命令行传参 可变参数 递归 原子性：一个方法最好只完成一个功能，方便维护 方法的定义类似于其他语言的函数 方法包含一个方法头和一个方法体 1234修饰符 返回值类型 方法名(参数类型 参数名)&#123; //方法体 return 返回值;&#125; 形式参数：在方法被调用时用于接收外界输入的数据 实际参数：调用方法时实际传给方法的数据 方法的调用调用方法：对象名.方法名（实参列表） 值传递(java)和引用传递 方法的重载在一个类中，有相同的类型，但是有不同的参数类型 仅仅方法的返回值类型不同不可以是重载 命令行传参1234567public class CommandLine&#123; public static void main(String[] args)&#123; for(int i=0; i&lt;args.length;i++)&#123; System.out.println(args[i]); &#125; &#125;&#125; 可变参数（不定项参数）JDK1.5开始，Java支持传递同类型的可变参数给一个方法 在指定参数类型后加一个省略号，三个点(…) 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明 123public void test(int... num)&#123; //相当于是传递了num[]数组进来&#125; 递归递归头：什么时候不调用自身方法，如果没有头，将陷入死循环 递归体：什么时候调用自身方法 很占资源，容易卡死","categories":[],"tags":[]},{"title":"java流程控制","slug":"java流程控制","date":"2021-08-05T13:53:59.000Z","updated":"2021-08-05T13:59:56.764Z","comments":true,"path":"2021/08/05/java流程控制/","link":"","permalink":"http://example.com/2021/08/05/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"Scanner对象 顺序结构 选择结构 循环结构","text":"Scanner对象 顺序结构 选择结构 循环结构 Scanner对象java.util.Scanner Java5的新特性，可以通过Scanner类来获取用户的输入 基本语法 1Scanner s = new Scanner(System.in); 通过next()和nextLine()获取字符串 通过hasNext()和hasNextLine()判断有没有输入 属于io流如果不关闭会一直占用资源，记得scanner.close() next() 一定要读取到有效字符后才可以结束输入 对输入有效字符之前遇到的空白，next()方法会自动将其去掉 输入有效字符后，将输入的空白作为分隔符或结束符 next()不能得到带有空格的字符串 nextLine() 以Enter为结束符 可以获得空白 顺序结构最基本的默认结构，从上到下执行 选择结构 if单选择结构 123if()&#123; &#125; if双选择结构 12345if()&#123; &#125;else&#123; &#125; if多选择结构 123456789if()&#123; &#125;else if()&#123; &#125;else if()&#123; &#125;else&#123; &#125; switch多选择结构 12345678910switch()&#123; case value1: //语句 break; case value2: //语句 break; default: //语句&#125; switch语句中的变量类型可以是byte, short, int, char, String(从Java SE 7开始支持) case标签必须为字符串常量或者字面量 case没有break把后面的所有语句全执行 循环结构 while循环 1234567while()&#123; &#125;while(true)&#123;//死循环 //服务器监听响应&#125; do..while循环 123do&#123; &#125;while()//循环体至少会执行一次 for循环 1234for(初始化;布尔表达式;更新)&#123; //初始化语句可以是空语句，也可以是一种类型多个变量 //布尔表达式和更新也可以是空语句，即for(;;)&#123;&#125;是死循环&#125; 增强for循环 Java5引入的一种主要用于数组或者集合的增强型for循环 1234for(声明语句:表达式)&#123; //声明语句：声明新的局部变量，变量的类型必须和数组元素的类型匹配。作用域限定值循环语句块，其值与此时数组元素的值相等 //表达式：是要访问的数组名，或者是返回值为数组的方法&#125; break和continue break：退出整个循环 continue：退出本轮循环","categories":[],"tags":[]},{"title":"java基础语法","slug":"java基础语法","date":"2021-08-02T14:22:04.000Z","updated":"2021-08-05T16:46:37.573Z","comments":true,"path":"2021/08/02/java基础语法/","link":"","permalink":"http://example.com/2021/08/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"注释 标识符 数据类型 类型转换 变量 常量 变量命名规范 运算法 包机制 JavaDoc","text":"注释 标识符 数据类型 类型转换 变量 常量 变量命名规范 运算法 包机制 JavaDoc 注释单行注释 1//单行注释 多行注释 12345/*多行注释多行注释多行注释*/ 文档注释（JavaDoc） 1234/** *@Description HelloWorld *@Author RW */ 标识符类名，方法名，变量名都是标识符 所有标识符必须以A-Z, a-z, $, _开始 首字符之后的可以是A-Z, a-z, $, _，数字 不能用关键字 标识符大小写敏感 可以用中文，但是不建议 关键字 String不是关键字，是类 数据类型java，c++是强类型语言（所有变量必须先定义后使用） 安全性高，速度慢 js是弱类型语言 java的数据类型分为两大类 基本类型 整数类型：byte占1字节, short占2字节, int占4字节, long占8字节 long类型要在数字后面加L， long num = 30L; 浮点类型：float占4字节, double占8字节 float类型要在数字后面加F， float num = 30F; 字符类型：char占2字节 boolean类型：占1位 值只有true和false 引用类型 类 接口 数组 java中表示进制 二进制 0b 八进制 0 十六进制 0x 浮点数（float double）是离散的，有舍入误差，接近但不等于 123float f = 0.1f;//0.1double d = 1.0/10;//0,1System.out.println(f==d); //会输出false 123float d1 = 2313131323123113f;float d2 = d1 + 1;System.out.println(d1==d2); //会输出true 因此，最好避免使用浮点数进行比较 所有的字符本质还是数字 编码 Unicode 2字节 0-65536 1char c = &#x27;\\u0061&#x27;; //c输出‘a&#x27; 转义字符 \\t 制表符 \\n 换行 ……. 类型转换低—————————————————————&gt;高 byte,short,char –&gt; int –&gt; long –&gt; float –&gt; double 从低到高，占的位越来越多，且小数高于整数 强制转换 高-低 (类型)变量名 e.g. int(100) 自动转换 低-高 注意点： 不能对布尔值进行转换 不能把对象类型转换为不相干类型 再把高容量转换到低容量时，要做强制转换 转换的时候可能存在内存溢出或者精度的问题 在操作比较大的数的时候，要注意溢出 tips：JDK7新特性，大的数可以在中间加下划线方便看 比如1_0000_0000 变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域 变量作用域 类变量 实例变量：从属于对象（类）可以不初始化值，有自动初始化 数值类型初始化默认0 0.0 布尔值默认是false 除了基本变量，其余的默认值都为null(比如string) 局部变量：必须声明和初始化值 不会自动初始化 1234567public class demo&#123; static double salary = 2500;//类变量 String str = &#x27;abc&#x27;;//实例变量 public static void main(String[] args)&#123; int a = 0;//局部变量 &#125;&#125; 常量初始化后不能再改值 1static final double PI = 3.14;//常量名一般使用大写字符 tip：public，final和static都是修饰符，不存在先后顺序 变量命名规范类成员变量，局部变量：首字母小写，驼峰 常量：大写字母和下划线 MAX_VALUE 类名：首字母大写，驼峰 方法名：首字母小写，驼峰 run() 运算符算数运算符：+ - * / % ++ – (++a是先自增在赋值，a++是先赋值再自增) 赋值运算符：= 关系运算符：&gt;, &lt;, &gt;=, &lt;=, ==, !=, instanceof 逻辑运算符（与或非）：&amp;&amp; || ! 短路运算：a&amp;&amp;b 如果a已经是假的，那么不在看b 位运算符： &amp; | ^ ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; 2*8=16 可以是2&lt;&lt;3 = 16 条件运算符： ? : 扩展赋值运算符： +=, -=, *=, /= 12345678910long a = 23123123;int b= 123;short c = 10;byte d = 8;/*a+b+c+d结果是Long类型b+c+d结果是int类型c+d结果是int类型因为有long就是long，没有long就是int*/ 包机制本质就是文件夹 格式是package com.baidu.baike; 且必须在前上面 一般利用公司域名倒置作为包名 JavaDoc用来生成自己API文档 参数信息 @author作者名 @version版本号 @since指明需要最早使用的jdk版本 @param参数名 @return返回值情况 @throws异常抛出情况 生成步骤（也可以用idea之类的打开） ​ 找到java文件所在文件夹，打开cmd ​ 输入javadoc -encoding UTF-8 -charset UTF-8 Doc.java ​ 然后在文件夹中就可以找到","categories":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/categories/java-SE/"}],"tags":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/tags/java-SE/"}]},{"title":"win10下基于hexo+github搭建个人博客过程","slug":"win10下基于hexo-github搭建个人博客过程","date":"2021-08-02T12:50:31.000Z","updated":"2021-08-02T14:10:54.605Z","comments":true,"path":"2021/08/02/win10下基于hexo-github搭建个人博客过程/","link":"","permalink":"http://example.com/2021/08/02/win10%E4%B8%8B%E5%9F%BA%E4%BA%8Ehexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/","excerpt":"这个博客就是基于hexo+github所搭建的网站，在此先记录一下搭建的过程","text":"这个博客就是基于hexo+github所搭建的网站，在此先记录一下搭建的过程 Step1 安装nodejs在https://nodejs.org/上下载14.17.4LTS（我搭建时的最新版本） 下载完后直接无脑下一步安装就好。（亲测没必要装在c盘） 安装完之后，win+R调出搜索，输入cmd，打开命令行，分别输入 1node -v 1npm -v 查看是否成功安装。 Step2 安装cnpm在命令行中输入 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完之后输入 1cnpm -v 查看是否成功安装 Step3 用cnpm安装hexo框架在命令行中输入 1cnpm install -g hexo-cli 安装完之后输入 1hexo -v 查看是否成功安装 Step4 在任意位置建立空文件夹这个文件夹用于存放博客的所有内容。e.g.我的路径是E:\\study\\blog\\ Step5 进入刚刚创建的文件夹在空白处按住shift单击右键打开PowerShell窗口。在命令行中输入 1hexo init 这里注意由于我的路径是在E盘中，所以并没有管理员权限的问题，如果在c盘可能会有（我没自己试过） 初始化后进入文件夹会发现出现很多文件。 Step6 启动hexo还是在blog文件夹下打开PowerShell窗口。在命令行中输入 1hexo s 会出现提示http://localhost:4000/，在浏览器输入这个网址进入博客。Ctrl+c退出 Step7 创建文章还是在blog文件夹下打开PowerShell窗口。在命令行中输入 1hexo n &#x27;文章名字&#x27; 之后进入/source/posts，发现新出现了一个 文章名字.md 的文件。直接txt格式打开用markdown格式写文章就行。 Step8 上传文章返回blog文件夹下打开PowerShell窗口。在命令行中输入 123hexo cleanhexo ghexo s 再从http://localhost:4000/进入博客，发现文章已经上传。 Step9 将博客部署到githubhttps://github.com/登陆自己的github账号，点右上角的+，New repository 在Repository name输入 自己的github名.github.io 比如我的github叫enheng244，我就是enheng244.github.io 然后Create repository 在blog文件夹下打开PowerShell窗口。在命令行中输入 1cnpm install --save hexo-deployer-git 安装完之后，在blog文件下找到_config.yml，进入后在最底部找到#Deployment，配置如下 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/enheng244/enheng244.github.io.git branch: master repo行换成自己的github地址即可。 Step10 进入博客此时在浏览器输入enheng244.github.io即可访问自己的博客 Step11 换主题在github上或其他地方可以找到很多主题，可以按照其中的文档去换主题 Step12 常用命令1234hexo cleanhexo ghexo s hexo d","categories":[],"tags":[]},{"title":"markdown语法总结","slug":"markdown语法总结","date":"2021-08-02T10:35:12.000Z","updated":"2021-08-05T13:55:53.823Z","comments":true,"path":"2021/08/02/markdown语法总结/","link":"","permalink":"http://example.com/2021/08/02/markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"从前只是零零散散的用过一些markdown形式，既然下定决心要开始写博客了，所有最先做的先要把markdown的语法先过一遍，以后就不用再每次用的时候去一直百度。","text":"从前只是零零散散的用过一些markdown形式，既然下定决心要开始写博客了，所有最先做的先要把markdown的语法先过一遍，以后就不用再每次用的时候去一直百度。 标题一级标题（一个# + 空格 + 标题名）二级标题（二个# + 空格 + 标题名）三级标题（三个# + 空格 + 标题名）四级标题（四个# + 空格 + 标题名）五级标题（五个# + 空格 + 标题名）最多支持到六级标题（六个# + 空格 + 标题名）字体Hello.World!(粗体前后各加两个星号) Hello.World!（斜体前后各加一个星号） Hello.World!（粗体加粗体前后各加三个星号） Hello.World!（前后各加两个波浪号） 引用 前面&gt;加空格 分割线三个减号— 三个星号*** 图片感叹号中括号小括号前面写图片名后面写路径 可以是本地的也可是网上的路径 超链接点击跳转到百度 中括号小括号前面写文字后面写网址 列表有序列表： 1.空格 a b c 无序列表： -空格 a b c 表格名字|性别|生日 –|–|–| 张三|男|1997.1.1 名字 性别 生日 张三 男 1997.1.1 代码三个` （tab上面的）+ 语言，比如java + 回车 1import","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-08-01T16:52:41.360Z","updated":"2021-08-02T12:45:19.379Z","comments":true,"path":"2021/08/02/hello-world/","link":"","permalink":"http://example.com/2021/08/02/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/categories/java-SE/"}],"tags":[{"name":"java SE","slug":"java-SE","permalink":"http://example.com/tags/java-SE/"}]}